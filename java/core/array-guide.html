<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java Arrays: Basic to Advanced Guide</title>
    <link rel="icon" type="image/png" href="/assets/images/logo.png">
    <link rel="stylesheet" href="/css/styles.css">
</head>

<body>
    <div class="container">
        <!-- Title Page -->
        <div class="title-page">
            <h1 class="main-title">Java Arrays</h1>
            <h2 class="subtitle">Basic to Advanced Guide</h2>
            <div class="author">By Mohammad S Hossain</div>
        </div>

        <!-- Table of Contents -->
        <div class="toc-page">
            <h2>Table of Contents</h2>
            <ul class="toc">
                <li><a href="#chapter1">Chapter 1: Array Fundamentals</a></li>
                <li><a href="#chapter2">Chapter 2: Array Declaration and Initialization</a></li>
                <li><a href="#chapter3">Chapter 3: Array Operations</a></li>
                <li><a href="#chapter4">Chapter 4: Multidimensional Arrays</a></li>
                <li><a href="#chapter5">Chapter 5: Array Algorithms</a></li>
                <li><a href="#chapter6">Chapter 6: Advanced Array Techniques</a></li>
                <li><a href="#chapter7">Chapter 7: Performance and Memory</a></li>
                <li><a href="#chapter8">Chapter 8: Arrays vs Collections</a></li>
            </ul>
        </div>

        <!-- Chapter 1: Array Fundamentals -->
        <div class="chapter" id="chapter1">
            <h2>Chapter 1: Array Fundamentals</h2>

            <h3>What is an Array?</h3>
            <p>An array is a container object that holds a fixed number of values of a single type. Arrays are
                fundamental data structures in Java that store elements in contiguous memory locations.</p>

            <div class="note-box">
                <strong>Key Characteristics:</strong>
                <ul>
                    <li>Fixed size once created</li>
                    <li>Elements are of the same data type</li>
                    <li>Zero-based indexing</li>
                    <li>Reference type in Java</li>
                </ul>
            </div>

            <h3>Array Memory Structure</h3>
            <div class="visual-diagram">
                <pre>
Array: [10, 20, 30, 40, 50]
Index:  0   1   2   3   4
Memory: [10][20][30][40][50]
        ↑
    Base Address
                </pre>
            </div>

            <h3>Basic Array Syntax</h3>
            <div class="code-block">
                <pre><code>// Declaration
int[] numbers;
String[] names;

// Declaration with initialization
int[] scores = new int[5];
String[] cities = new String[10];

// Declaration with values
int[] values = {1, 2, 3, 4, 5};
String[] colors = {"red", "green", "blue"};
</code></pre>
            </div>

            <div class="tip-box">
                <strong>Tip:</strong> Use meaningful variable names for arrays. Instead of 'arr', use descriptive names
                like 'studentGrades' or 'employeeNames'.
            </div>
        </div>

        <!-- Chapter 2: Declaration and Initialization -->
        <div class="chapter" id="chapter2">
            <h2>Chapter 2: Array Declaration and Initialization</h2>

            <h3>Different Ways to Declare Arrays</h3>
            <div class="code-block">
                <pre><code>// Method 1: Square brackets after type
int[] numbers1;
String[] words1;

// Method 2: Square brackets after variable name
int numbers2[];
String words2[];

// Method 3: Multiple arrays of same type
int[] arr1, arr2, arr3;
</code></pre>
            </div>

            <h3>Array Initialization Techniques</h3>

            <h4>1. Default Initialization</h4>
            <div class="code-block">
                <pre><code>int[] numbers = new int[5]; // [0, 0, 0, 0, 0]
boolean[] flags = new boolean[3]; // [false, false, false]
String[] names = new String[2]; // [null, null]
</code></pre>
            </div>

            <h4>2. Literal Initialization</h4>
            <div class="code-block">
                <pre><code>int[] primes = {2, 3, 5, 7, 11, 13};
String[] days = {"Monday", "Tuesday", "Wednesday"};
double[] prices = {19.99, 29.50, 15.75};
</code></pre>
            </div>

            <h4>3. Anonymous Array</h4>
            <div class="code-block">
                <pre><code>// Useful for method parameters
processArray(new int[]{1, 2, 3, 4, 5});

// Or for reinitializing
numbers = new int[]{10, 20, 30};
</code></pre>
            </div>

            <table class="comparison-table">
                <tr>
                    <th>Data Type</th>
                    <th>Default Value</th>
                    <th>Example</th>
                </tr>
                <tr>
                    <td>int, byte, short, long</td>
                    <td>0</td>
                    <td>int[] arr = new int[3]; // [0, 0, 0]</td>
                </tr>
                <tr>
                    <td>float, double</td>
                    <td>0.0</td>
                    <td>double[] arr = new double[2]; // [0.0, 0.0]</td>
                </tr>
                <tr>
                    <td>boolean</td>
                    <td>false</td>
                    <td>boolean[] arr = new boolean[2]; // [false, false]</td>
                </tr>
                <tr>
                    <td>char</td>
                    <td>'\u0000'</td>
                    <td>char[] arr = new char[2]; // ['\u0000', '\u0000']</td>
                </tr>
                <tr>
                    <td>Object references</td>
                    <td>null</td>
                    <td>String[] arr = new String[2]; // [null, null]</td>
                </tr>
            </table>
        </div>

        <!-- Chapter 3: Array Operations -->
        <div class="chapter" id="chapter3">
            <h2>Chapter 3: Array Operations</h2>

            <h3>Accessing Array Elements</h3>
            <div class="code-block">
                <pre><code>int[] numbers = {10, 20, 30, 40, 50};

// Reading elements
int first = numbers[0];    // 10
int last = numbers[numbers.length - 1]; // 50

// Modifying elements
numbers[2] = 35;  // Array becomes {10, 20, 35, 40, 50}

// Getting array length
int size = numbers.length; // 5
</code></pre>
            </div>

            <h3>Iterating Through Arrays</h3>

            <h4>1. Traditional For Loop</h4>
            <div class="code-block">
                <pre><code>int[] scores = {85, 92, 78, 96, 88};

for (int i = 0; i < scores.length; i++) {
    System.out.println("Score " + (i + 1) + ": " + scores[i]);
}
</code></pre>
            </div>

            <h4>2. Enhanced For Loop (For-Each)</h4>
            <div class="code-block">
                <pre><code>String[] fruits = {"Apple", "Banana", "Orange", "Grape"};

for (String fruit : fruits) {
    System.out.println("Fruit: " + fruit);
}
</code></pre>
            </div>

            <h4>3. While Loop</h4>
            <div class="code-block">
                <pre><code>int[] values = {5, 10, 15, 20};
int index = 0;

while (index < values.length) {
    System.out.println(values[index]);
    index++;
}
</code></pre>
            </div>

            <div class="note-box">
                <strong>ArrayIndexOutOfBoundsException:</strong> This runtime exception occurs when trying to access an
                invalid index. Always ensure your index is between 0 and array.length - 1.
            </div>

            <h3>Common Array Operations</h3>
            <div class="code-block">
                <pre><code>public class ArrayOperations {
    
    // Find maximum element
    public static int findMax(int[] arr) {
        int max = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        return max;
    }
    
    // Calculate sum
    public static int calculateSum(int[] arr) {
        int sum = 0;
        for (int num : arr) {
            sum += num;
        }
        return sum;
    }
    
    // Search for element
    public static boolean contains(int[] arr, int target) {
        for (int num : arr) {
            if (num == target) {
                return true;
            }
        }
        return false;
    }
    
    // Reverse array in place
    public static void reverseArray(int[] arr) {
        int start = 0;
        int end = arr.length - 1;
        
        while (start < end) {
            // Swap elements
            int temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            
            start++;
            end--;
        }
    }
}
</code></pre>
            </div>
        </div>

        <!-- Chapter 4: Multidimensional Arrays -->
        <div class="chapter" id="chapter4">
            <h2>Chapter 4: Multidimensional Arrays</h2>

            <h3>2D Arrays</h3>
            <p>A 2D array is an array of arrays, commonly used to represent matrices, tables, or grids.</p>

            <div class="visual-diagram">
                <pre>
2D Array Structure:
    Col0  Col1  Col2
Row0 [1]   [2]   [3]
Row1 [4]   [5]   [6]
Row2 [7]   [8]   [9]
                </pre>
            </div>

            <h4>Declaration and Initialization</h4>
            <div class="code-block">
                <pre><code>// Declaration
int[][] matrix;

// Initialization with size
int[][] grid = new int[3][4]; // 3 rows, 4 columns

// Initialization with values
int[][] numbers = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

// Jagged arrays (different column sizes)
int[][] jaggedArray = {
    {1, 2},
    {3, 4, 5, 6},
    {7}
};
</code></pre>
            </div>

            <h4>Working with 2D Arrays</h4>
            <div class="code-block">
                <pre><code>public class Matrix2D {
    
    // Print 2D array
    public static void printMatrix(int[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                System.out.print(matrix[i][j] + " ");
            }
            System.out.println();
        }
    }
    
    // Sum of all elements
    public static int sumMatrix(int[][] matrix) {
        int sum = 0;
        for (int[] row : matrix) {
            for (int element : row) {
                sum += element;
            }
        }
        return sum;
    }
    
    // Matrix addition
    public static int[][] addMatrices(int[][] a, int[][] b) {
        int rows = a.length;
        int cols = a[0].length;
        int[][] result = new int[rows][cols];
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result[i][j] = a[i][j] + b[i][j];
            }
        }
        return result;
    }
    
    // Transpose matrix
    public static int[][] transpose(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        int[][] transposed = new int[cols][rows];
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                transposed[j][i] = matrix[i][j];
            }
        }
        return transposed;
    }
}
</code></pre>
            </div>

            <h3>3D Arrays and Beyond</h3>
            <div class="code-block">
                <pre><code>// 3D array declaration
int[][][] cube = new int[3][4][5]; // 3x4x5 cube

// Initialization with values
int[][][] data = {
    {{1, 2}, {3, 4}},
    {{5, 6}, {7, 8}},
    {{9, 10}, {11, 12}}
};

// Accessing 3D array elements
int value = cube[1][2][3]; // layer 1, row 2, column 3
cube[0][1][2] = 42;        // assignment
</code></pre>
            </div>

            <div class="tip-box">
                <strong>Memory Tip:</strong> Multidimensional arrays in Java are arrays of references to other arrays.
                This allows for jagged arrays where sub-arrays can have different lengths.
            </div>
        </div>

        <!-- Chapter 5: Array Algorithms -->
        <div class="chapter" id="chapter5">
            <h2>Chapter 5: Array Algorithms</h2>

            <h3>Searching Algorithms</h3>

            <h4>Linear Search</h4>
            <div class="code-block">
                <pre><code>public static int linearSearch(int[] arr, int target) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == target) {
            return i; // Return index if found
        }
    }
    return -1; // Not found
}

// Time Complexity: O(n)
// Space Complexity: O(1)
</code></pre>
            </div>

            <h4>Binary Search (for sorted arrays)</h4>
            <div class="code-block">
                <pre><code>public static int binarySearch(int[] arr, int target) {
    int left = 0;
    int right = arr.length - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1; // Not found
}

// Time Complexity: O(log n)
// Space Complexity: O(1)
</code></pre>
            </div>

            <h3>Sorting Algorithms</h3>

            <h4>Bubble Sort</h4>
            <div class="code-block">
                <pre><code>public static void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        boolean swapped = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Swap elements
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = true;
            }
        }
        if (!swapped) break; // Optimization: early termination
    }
}

// Time Complexity: O(n²) average and worst case, O(n) best case
// Space Complexity: O(1)
</code></pre>
            </div>

            <h4>Selection Sort</h4>
            <div class="code-block">
                <pre><code>public static void selectionSort(int[] arr) {
    int n = arr.length;
    
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        
        // Find minimum element in remaining array
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        
        // Swap minimum element with first element
        if (minIndex != i) {
            int temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
        }
    }
}

// Time Complexity: O(n²)
// Space Complexity: O(1)
</code></pre>
            </div>

            <h4>Quick Sort</h4>
            <div class="code-block">
                <pre><code>public static void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pivotIndex = partition(arr, low, high);
        
        quickSort(arr, low, pivotIndex - 1);  // Sort left half
        quickSort(arr, pivotIndex + 1, high); // Sort right half
    }
}

private static int partition(int[] arr, int low, int high) {
    int pivot = arr[high]; // Choose last element as pivot
    int i = low - 1;
    
    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr, i, j);
        }
    }
    swap(arr, i + 1, high);
    return i + 1;
}

private static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

// Time Complexity: O(n log n) average, O(n²) worst case
// Space Complexity: O(log n)
</code></pre>
            </div>

            <table class="comparison-table">
                <tr>
                    <th>Algorithm</th>
                    <th>Best Case</th>
                    <th>Average Case</th>
                    <th>Worst Case</th>
                    <th>Space Complexity</th>
                </tr>
                <tr>
                    <td>Bubble Sort</td>
                    <td>O(n)</td>
                    <td>O(n²)</td>
                    <td>O(n²)</td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Selection Sort</td>
                    <td>O(n²)</td>
                    <td>O(n²)</td>
                    <td>O(n²)</td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Quick Sort</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>O(n²)</td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td>Arrays.sort()</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>O(log n)</td>
                </tr>
            </table>
        </div>

        <!-- Chapter 6: Advanced Array Techniques -->
        <div class="chapter" id="chapter6">
            <h2>Chapter 6: Advanced Array Techniques</h2>

            <h3>Using java.util.Arrays Class</h3>
            <div class="code-block">
                <pre><code>import java.util.Arrays;

public class ArraysUtility {
    public static void demonstrateArrays() {
        int[] numbers = {5, 2, 8, 1, 9};
        
        // Sorting
        Arrays.sort(numbers);
        System.out.println(Arrays.toString(numbers)); // [1, 2, 5, 8, 9]
        
        // Binary search (array must be sorted)
        int index = Arrays.binarySearch(numbers, 5);
        System.out.println("Index of 5: " + index); // 2
        
        // Fill array with same value
        int[] filled = new int[5];
        Arrays.fill(filled, 42);
        System.out.println(Arrays.toString(filled)); // [42, 42, 42, 42, 42]
        
        // Copy array
        int[] copy = Arrays.copyOf(numbers, numbers.length);
        int[] partialCopy = Arrays.copyOfRange(numbers, 1, 4);
        
        // Compare arrays
        boolean areEqual = Arrays.equals(numbers, copy);
        
        // Deep operations for multidimensional arrays
        int[][] matrix = {{1, 2}, {3, 4}};
        System.out.println(Arrays.deepToString(matrix));
    }
}
</code></pre>
            </div>

            <h3>Array Copying Techniques</h3>
            <div class="code-block">
                <pre><code>public class ArrayCopyDemo {
    public static void demonstrateCopyMethods() {
        int[] original = {1, 2, 3, 4, 5};
        
        // Method 1: Arrays.copyOf()
        int[] copy1 = Arrays.copyOf(original, original.length);
        
        // Method 2: System.arraycopy()
        int[] copy2 = new int[original.length];
        System.arraycopy(original, 0, copy2, 0, original.length);
        
        // Method 3: clone() - shallow copy
        int[] copy3 = original.clone();
        
        // Method 4: Manual copying
        int[] copy4 = new int[original.length];
        for (int i = 0; i < original.length; i++) {
            copy4[i] = original[i];
        }
        
        // For partial copying
        int[] partial = Arrays.copyOfRange(original, 1, 4); // [2, 3, 4]
    }
}
</code></pre>
            </div>

            <h3>Dynamic Arrays and Resizing</h3>
            <div class="code-block">
                <pre><code>public class DynamicArray {
    private int[] array;
    private int size;
    private int capacity;
    
    public DynamicArray() {
        capacity = 10;
        array = new int[capacity];
        size = 0;
    }
    
    public void add(int element) {
        if (size >= capacity) {
            resize();
        }
        array[size] = element;
        size++;
    }
    
    private void resize() {
        capacity *= 2; // Double the capacity
        int[] newArray = new int[capacity];
        System.arraycopy(array, 0, newArray, 0, size);
        array = newArray;
    }
    
    public int get(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("Index: " + index);
        }
        return array[index];
    }
    
    public void remove(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("Index: " + index);
        }
        
        // Shift elements left
        for (int i = index; i < size - 1; i++) {
            array[i] = array[i + 1];
        }
        size--;
    }
    
    public int size() {
        return size;
    }
}
</code></pre>
            </div>

            <h3>Advanced Array Algorithms</h3>

            <h4>Two-Pointer Technique</h4>
            <div class="code-block">
                <pre><code>public class TwoPointerTechniques {
    
    // Find pair with target sum in sorted array
    public static boolean findPairWithSum(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left < right) {
            int sum = arr[left] + arr[right];
            if (sum == target) {
                return true;
            } else if (sum < target) {
                left++;
            } else {
                right--;
            }
        }
        return false;
    }
    
    // Remove duplicates from sorted array in-place
    public static int removeDuplicates(int[] arr) {
        if (arr.length == 0) return 0;
        
        int writeIndex = 1;
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] != arr[i - 1]) {
                arr[writeIndex] = arr[i];
                writeIndex++;
            }
        }
        return writeIndex;
    }
}
</code></pre>
            </div>

            <h4>Sliding Window Technique</h4>
            <div class="code-block">
                <pre><code>public class SlidingWindow {
    
    // Find maximum sum of k consecutive elements
    public static int maxSumSubarray(int[] arr, int k) {
        if (arr.length < k) return -1;
        
        // Calculate sum of first window
        int windowSum = 0;
        for (int i = 0; i < k; i++) {
            windowSum += arr[i];
        }
        
        int maxSum = windowSum;
        
        // Slide the window
        for (int i = k; i < arr.length; i++) {
            windowSum += arr[i] - arr[i - k];
            maxSum = Math.max(maxSum, windowSum);
        }
        
        return maxSum;
    }
    
    // Find longest subarray with sum <= target
    public static int longestSubarrayWithSum(int[] arr, int target) {
        int left = 0;
        int currentSum = 0;
        int maxLength = 0;
        
        for (int right = 0; right < arr.length; right++) {
            currentSum += arr[right];
            
            while (currentSum > target && left <= right) {
                currentSum -= arr[left];
                left++;
            }
            
            maxLength = Math.max(maxLength, right - left + 1);
        }
        
        return maxLength;
    }
}
</code></pre>
            </div>
        </div>

        <!-- Chapter 7: Performance and Memory -->
        <div class="chapter" id="chapter7">
            <h2>Chapter 7: Performance and Memory</h2>

            <h3>Array Performance Characteristics</h3>
            <table class="comparison-table">
                <tr>
                    <th>Operation</th>
                    <th>Time Complexity</th>
                    <th>Notes</th>
                </tr>
                <tr>
                    <td>Access by index</td>
                    <td>O(1)</td>
                    <td>Direct memory access</td>
                </tr>
                <tr>
                    <td>Search (unsorted)</td>
                    <td>O(n)</td>
                    <td>Linear search required</td>
                </tr>
                <tr>
                    <td>Search (sorted)</td>
                    <td>O(log n)</td>
                    <td>Binary search possible</td>
                </tr>
                <tr>
                    <td>Insert at end</td>
                    <td>O(1)</td>
                    <td>If space available</td>
                </tr>
                <tr>
                    <td>Insert at beginning</td>
                    <td>O(n)</td>
                    <td>Requires shifting elements</td>
                </tr>
                <tr>
                    <td>Delete</td>
                    <td>O(n)</td>
                    <td>May require shifting elements</td>
                </tr>
            </table>

            <h3>Memory Usage</h3>
            <div class="note-box">
                <strong>Memory Layout:</strong>
                <ul>
                    <li>Arrays store elements in contiguous memory</li>
                    <li>Array object itself has overhead (typically 12-16 bytes)</li>
                    <li>Each element takes space based on data type</li>
                    <li>Reference arrays store pointers, not actual objects</li>
                </ul>
            </div>

            <div class="code-block">
                <pre><code>public class ArrayMemoryDemo {
    public static void analyzeMemoryUsage() {
        // Primitive array - stores actual values
        int[] intArray = new int[1000]; // ~4KB + overhead
        
        // Object array - stores references
        String[] stringArray = new String[1000]; // ~4KB + overhead for references
        // Actual strings stored separately in heap
        
        // Memory calculation example:
        // int array of size n: n * 4 bytes + array overhead
        // String array of size n: n * 4 bytes (references) + overhead
        //                       + actual string memory in heap
    }
    
    public static void demonstrateShallowVsDeepCopy() {
        // Shallow copy - references copied, objects shared
        String[] original = {"Hello", "World"};
        String[] shallowCopy = original.clone();
        
        // Both arrays share the same string objects
        System.out.println(original[0] == shallowCopy[0]); // true
        
        // For mutable objects, changes affect both arrays
        StringBuilder[] sbArray = {new StringBuilder("Hello")};
        StringBuilder[] sbCopy = sbArray.clone();
        sbCopy[0].append(" World"); // Affects both arrays!
        
        System.out.println(sbArray[0].toString()); // "Hello World"
    }
}
</code></pre>
            </div>

            <h3>Performance Optimization Tips</h3>
            <div class="tip-box">
                <strong>Optimization Strategies:</strong>
                <ul>
                    <li>Use primitive arrays instead of wrapper classes when possible</li>
                    <li>Access arrays sequentially for better cache performance</li>
                    <li>Avoid frequent resizing operations</li>
                    <li>Pre-allocate arrays with known size</li>
                    <li>Use System.arraycopy() for bulk operations</li>
                </ul>
            </div>

            <div class="code-block">
                <pre><code>public class PerformanceComparison {
    
    // Inefficient: Boxing/unboxing overhead
    public static void inefficientSum(Integer[] arr) {
        long sum = 0;
        for (Integer num : arr) { // Unboxing overhead
            sum += num;
        }
    }
    
    // Efficient: Primitive array
    public static void efficientSum(int[] arr) {
        long sum = 0;
        for (int num : arr) { // No boxing overhead
            sum += num;
        }
    }
    
    // Cache-friendly access pattern
    public static void cacheFriendlyAccess(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        
        // Row-major access (cache-friendly)
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                process(matrix[i][j]);
            }
        }
    }
    
    // Cache-unfriendly access pattern
    public static void cacheUnfriendlyAccess(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        
        // Column-major access (cache-unfriendly)
        for (int j = 0; j < cols; j++) {
            for (int i = 0; i < rows; i++) {
                process(matrix[i][j]);
            }
        }
    }
    
    private static void process(int value) {
        // Processing logic
    }
}
</code></pre>
            </div>
        </div>

        <!-- Chapter 8: Arrays vs Collections -->
        <div class="chapter" id="chapter8">
            <h2>Chapter 8: Arrays vs Collections</h2>

            <h3>When to Use Arrays</h3>
            <div class="note-box">
                <strong>Use Arrays When:</strong>
                <ul>
                    <li>Fixed size is known at compile time</li>
                    <li>Performance is critical (primitive types)</li>
                    <li>Memory usage needs to be minimized</li>
                    <li>Working with mathematical operations</li>
                    <li>Interfacing with native code or APIs</li>
                </ul>
            </div>

            <h3>When to Use Collections</h3>
            <div class="note-box">
                <strong>Use Collections When:</strong>
                <ul>
                    <li>Dynamic sizing is required</li>
                    <li>Need built-in utility methods</li>
                    <li>Type safety with generics is important</li>
                    <li>Integration with Java Collections Framework</li>
                    <li>Complex data manipulation is needed</li>
                </ul>
            </div>

            <h3>Comparison Example</h3>
            <div class="code-block">
                <pre><code>import java.util.*;

public class ArrayVsCollections {
    
    public static void arrayExample() {
        // Array approach
        int[] scores = new int[5];
        scores[0] = 85;
        scores[1] = 92;
        scores[2] = 78;
        scores[3] = 96;
        scores[4] = 88;
        
        // Manual operations
        int sum = 0;
        for (int score : scores) {
            sum += score;
        }
        double average = (double) sum / scores.length;
        
        Arrays.sort(scores);
        int max = scores[scores.length - 1];
    }
    
    public static void collectionExample() {
        // Collection approach
        List<Integer> scores = new ArrayList<>();
        scores.add(85);
        scores.add(92);
        scores.add(78);
        scores.add(96);
        scores.add(88);
        
        // Built-in operations
        int sum = scores.stream().mapToInt(Integer::intValue).sum();
        double average = scores.stream().mapToInt(Integer::intValue).average().orElse(0.0);
        
        Collections.sort(scores);
        int max = Collections.max(scores);
        
        // Easy manipulation
        scores.remove(Integer.valueOf(78));
        scores.add(2, 95);
    }
}
</code></pre>
            </div>

            <table class="comparison-table">
                <tr>
                    <th>Aspect</th>
                    <th>Arrays</th>
                    <th>Collections</th>
                </tr>
                <tr>
                    <td>Size</td>
                    <td>Fixed at creation</td>
                    <td>Dynamic</td>
                </tr>
                <tr>
                    <td>Memory</td>
                    <td>Lower overhead</td>
                    <td>Higher overhead</td>
                </tr>
                <tr>
                    <td>Performance</td>
                    <td>Faster for primitives</td>
                    <td>Slower due to boxing</td>
                </tr>
                <tr>
                    <td>Type Safety</td>
                    <td>Compile-time for primitives</td>
                    <td>Generic type safety</td>
                </tr>
                <tr>
                    <td>Utility Methods</td>
                    <td>Limited (Arrays class)</td>
                    <td>Rich API</td>
                </tr>
                <tr>
                    <td>Multidimensional</td>
                    <td>Native support</td>
                    <td>Nested collections</td>
                </tr>
            </table>

            <h3>Converting Between Arrays and Collections</h3>
            <div class="code-block">
                <pre><code>import java.util.*;

public class ArrayCollectionConversion {
    
    public static void arrayToCollection() {
        // Array to List
        String[] array = {"apple", "banana", "cherry"};
        
        // Method 1: Arrays.asList() - Fixed size list
        List<String> list1 = Arrays.asList(array);
        
        // Method 2: New ArrayList - Modifiable
        List<String> list2 = new ArrayList<>(Arrays.asList(array));
        
        // Method 3: Collections.addAll()
        List<String> list3 = new ArrayList<>();
        Collections.addAll(list3, array);
        
        // Method 4: Stream (Java 8+)
        List<String> list4 = Arrays.stream(array)
                                   .collect(Collectors.toList());
    }
    
    public static void collectionToArray() {
        List<String> list = Arrays.asList("apple", "banana", "cherry");
        
        // Method 1: toArray() - Returns Object[]
        Object[] objArray = list.toArray();
        
        // Method 2: toArray(T[]) - Returns typed array
        String[] stringArray1 = list.toArray(new String[0]);
        String[] stringArray2 = list.toArray(new String[list.size()]);
        
        // Method 3: Stream (Java 8+)
        String[] stringArray3 = list.stream().toArray(String[]::new);
    }
    
    public static void primitiveConversion() {
        // List<Integer> to int[]
        List<Integer> intList = Arrays.asList(1, 2, 3, 4, 5);
        int[] intArray = intList.stream().mapToInt(i -> i).toArray();
        
        // int[] to List<Integer>
        int[] array = {1, 2, 3, 4, 5};
        List<Integer> list = Arrays.stream(array)
                                   .boxed()
                                   .collect(Collectors.toList());
    }
}
</code></pre>
            </div>

            <h3>Best Practices and Common Pitfalls</h3>

            <h4>Common Mistakes</h4>
            <div class="code-block">
                <pre><code>public class CommonPitfalls {
    
    public static void demonstratePitfalls() {
        // Pitfall 1: Index out of bounds
        int[] arr = {1, 2, 3};
        // int value = arr[3]; // RuntimeException!
        
        // Solution: Always check bounds
        int index = 3;
        if (index >= 0 && index < arr.length) {
            int value = arr[index];
        }
        
        // Pitfall 2: Null array vs empty array
        int[] nullArray = null;
        int[] emptyArray = new int[0];
        
        // Always check for null
        if (nullArray != null && nullArray.length > 0) {
            // Safe to access
        }
        
        // Pitfall 3: Modifying array during iteration
        String[] names = {"Alice", "Bob", "Charlie"};
        // Don't modify array structure during iteration
        
        // Pitfall 4: Reference vs value confusion
        int[] original = {1, 2, 3};
        int[] reference = original; // Same array!
        int[] copy = original.clone(); // Different array
        
        reference[0] = 100; // Affects original
        copy[0] = 200;      // Doesn't affect original
    }
    
    public static void bestPractices() {
        // Best Practice 1: Use meaningful names
        int[] studentGrades = new int[30]; // Better than int[] arr
        
        // Best Practice 2: Initialize with expected size
        List<String> names = new ArrayList<>(100); // If you expect ~100 elements
        
        // Best Practice 3: Use enhanced for-loop when possible
        for (int grade : studentGrades) {
            System.out.println(grade);
        }
        
        // Best Practice 4: Validate inputs
        public static int findMax(int[] array) {
            if (array == null || array.length == 0) {
                throw new IllegalArgumentException("Array cannot be null or empty");
            }
            // Implementation...
        }
        
        // Best Practice 5: Use utility methods
        Arrays.sort(studentGrades);
        String arrayString = Arrays.toString(studentGrades);
    }
}
</code></pre>
            </div>

            <h3>Advanced Use Cases</h3>
            <div class="code-block">
                <pre><code>public class AdvancedArrayUseCases {
    
    // Array as a circular buffer
    public static class CircularBuffer {
        private int[] buffer;
        private int head, tail, size;
        
        public CircularBuffer(int capacity) {
            buffer = new int[capacity];
            head = tail = size = 0;
        }
        
        public boolean enqueue(int item) {
            if (size == buffer.length) return false;
            
            buffer[tail] = item;
            tail = (tail + 1) % buffer.length;
            size++;
            return true;
        }
        
        public Integer dequeue() {
            if (size == 0) return null;
            
            int item = buffer[head];
            head = (head + 1) % buffer.length;
            size--;
            return item;
        }
    }
    
    // Array as a bit set
    public static class BitArray {
        private int[] bits;
        private int size;
        
        public BitArray(int size) {
            this.size = size;
            this.bits = new int[(size + 31) / 32]; // Ceiling division
        }
        
        public void setBit(int index) {
            int wordIndex = index / 32;
            int bitIndex = index % 32;
            bits[wordIndex] |= (1 << bitIndex);
        }
        
        public boolean getBit(int index) {
            int wordIndex = index / 32;
            int bitIndex = index % 32;
            return (bits[wordIndex] & (1 << bitIndex)) != 0;
        }
    }
    
    // Array-based stack implementation
    public static class ArrayStack<T> {
        private Object[] array;
        private int top;
        private int capacity;
        
        public ArrayStack(int capacity) {
            this.capacity = capacity;
            this.array = new Object[capacity];
            this.top = -1;
        }
        
        public boolean push(T item) {
            if (top >= capacity - 1) return false;
            array[++top] = item;
            return true;
        }
        
        @SuppressWarnings("unchecked")
        public T pop() {
            if (top < 0) return null;
            T item = (T) array[top];
            array[top--] = null; // Help GC
            return item;
        }
        
        public boolean isEmpty() {
            return top < 0;
        }
    }
}
</code></pre>
            </div>

            <h3>Conclusion</h3>
            <p>Arrays are fundamental data structures in Java that provide efficient, direct access to elements. While
                they have limitations like fixed size, they remain crucial for performance-critical applications and
                serve as the foundation for many other data structures.</p>

            <div class="note-box">
                <strong>Key Takeaways:</strong>
                <ul>
                    <li>Arrays offer O(1) access time and minimal memory overhead</li>
                    <li>Use arrays for fixed-size, performance-critical scenarios</li>
                    <li>Collections provide more flexibility at the cost of overhead</li>
                    <li>Understanding both allows you to choose the right tool</li>
                    <li>Master array algorithms as they apply to many data structures</li>
                </ul>
            </div>

            <div class="tip-box">
                <strong>Next Steps:</strong> Practice implementing classic algorithms with arrays, explore advanced data
                structures built on arrays, and study the source code of Java's Collection classes to see how they use
                arrays internally.
            </div>
        </div>

        <!-- Footer -->
        <footer class="footer">
            <div id="footer-placeholder"></div>
        </footer>
        <script>
            fetch("../../footer.html")
                .then(res => res.text())
                .then(data => {
                    document.getElementById("footer-placeholder").innerHTML = data;
                });
        </script>
    </div>
</body>

</html>