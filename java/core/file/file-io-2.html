<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java File I/O - Complete Guide</title>
    <link rel="icon" type="image/png" href="/assets/images/logo.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="/css/styles.css">
    <link rel="stylesheet" href="/css/file-io/file-io-2.css">
    <link rel="stylesheet" href="/css/footer.css">
</head>

<body>
    <!-- Reading Progress Bar -->
    <div class="reading-progress" id="reading-progress"></div>

    <!-- Navigation -->
    <nav class="navbar">
        <div class="nav-container">
            <a href="/index.html" class="logo">
                <img src="/assets/images/logo.png" class="logo" width="50px" height="50px" alt="TechTok Cafe">
            </a>
            <ul class="nav-menu">
                <li class="nav-item"><a href="/index.html" class="nav-link"><i class="fas fa-home"></i>Home</a></li>
            </ul>
        </div>
    </nav>

    <!-- Back Navigation -->
    <div class="back-nav">
        <a href="/index.html" class="back-btn">
            <i class="fas fa-arrow-left"></i>
            Back to Home
        </a>
    </div>

    <!-- Main Content Container -->
    <div class="main-content">
        <!-- Chapter 5: Writing Files -->
        <div id="writing-files" class="chapter">
            <h2 class="chapter-title">5. Writing Files Efficiently</h2>
            <div class="chapter-content">
                <p>Modern Java provides multiple efficient ways to write files, each optimized for different scenarios. Choose wisely based on file size, content type, and performance requirements.</p>

                <h3 class="section-title">Writing Strategies - Complete Guide</h3>
                <div class="info-box">
                    <h4><i class="fas fa-pencil-alt"></i> When to Use Each Writing Method</h4>
                    <ul>
                        <li><strong>Files.writeString():</strong> Small text content, single write operation (Java 11+)</li>
                        <li><strong>Files.write():</strong> Writing byte arrays or lists of strings</li>
                        <li><strong>BufferedWriter:</strong> Multiple write operations, append mode, large text</li>
                        <li><strong>PrintWriter:</strong> Formatted output, printing methods</li>
                        <li><strong>FileChannel:</strong> Large binary files, async I/O, high performance</li>
                        <li><strong>DataOutputStream:</strong> Writing primitive data types</li>
                    </ul>
                </div>

                <h3 class="section-title">Text File Writing - Comprehensive Examples</h3>
                <div class="code-block">
                    <div class="code-title"><i class="fab fa-java"></i> Complete Text Writing Solutions</div>
                    <pre><span class="keyword">import</span> java.nio.file.*;
<span class="keyword">import</span> java.io.*;
<span class="keyword">import</span> java.util.*;

<span class="keyword">public class</span> <span class="type">TextFileWriting</span> {
    
    <span class="comment">// Method 1: Write String directly (Java 11+)</span>
    <span class="keyword">public static void</span> writeString(<span class="type">String</span> filename, <span class="type">String</span> content) 
            <span class="keyword">throws</span> <span class="type">IOException</span> {
        <span class="type">Files</span>.writeString(<span class="type">Path</span>.of(filename), content, 
            <span class="type">StandardCharsets</span>.UTF_8);
    }
    
    <span class="comment">// Method 2: BufferedWriter for incremental writing</span>
    <span class="keyword">public static void</span> writeWithBufferedWriter(<span class="type">String</span> filename) 
            <span class="keyword">throws</span> <span class="type">IOException</span> {
        <span class="keyword">try</span> (<span class="type">BufferedWriter</span> writer = <span class="type">Files</span>.newBufferedWriter(
                <span class="type">Path</span>.of(filename), <span class="type">StandardCharsets</span>.UTF_8)) {
            
            writer.write(<span class="string">"Header Line"</span>);
            writer.newLine();
            
            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {
                writer.write(<span class="string">"Data line "</span> + i);
                writer.newLine();
            }
            writer.flush();
        }
    }
    
    <span class="comment">// Method 3: Atomic write operation</span>
    <span class="keyword">public static void</span> writeAtomic(<span class="type">String</span> filename, <span class="type">String</span> content) 
            <span class="keyword">throws</span> <span class="type">IOException</span> {
        <span class="type">Path</span> target = <span class="type">Path</span>.of(filename);
        <span class="type">Path</span> temp = <span class="type">Files</span>.createTempFile(<span class="string">"temp"</span>, <span class="string">".tmp"</span>);
        
        <span class="keyword">try</span> {
            <span class="type">Files</span>.writeString(temp, content);
            <span class="type">Files</span>.move(temp, target, <span class="type">StandardCopyOption</span>.ATOMIC_MOVE);
        } <span class="keyword">finally</span> {
            <span class="type">Files</span>.deleteIfExists(temp);
        }
    }
}</pre>
                </div>

                <h3 class="section-title">Performance Comparison</h3>
                <div class="performance-grid">
                    <div class="performance-card">
                        <h4>Files.writeString()</h4>
                        <div class="performance-metric">
                            <span class="metric-name">Use Case</span>
                            <span class="metric-value">Small text files</span>
                        </div>
                        <div class="performance-metric">
                            <span class="metric-name">Performance</span>
                            <span class="metric-value metric-good">Fast</span>
                        </div>
                    </div>
                    <div class="performance-card">
                        <h4>BufferedWriter</h4>
                        <div class="performance-metric">
                            <span class="metric-name">Use Case</span>
                            <span class="metric-value">Large text files</span>
                        </div>
                        <div class="performance-metric">
                            <span class="metric-name">Performance</span>
                            <span class="metric-value metric-good">Efficient</span>
                        </div>
                    </div>
                    <div class="performance-card">
                        <h4>Memory-Mapped</h4>
                        <div class="performance-metric">
                            <span class="metric-name">Use Case</span>
                            <span class="metric-value">Large binary files</span>
                        </div>
                        <div class="performance-metric">
                            <span class="metric-name">Performance</span>
                            <span class="metric-value metric-good">Fastest</span>
                        </div>
                    </div>
                </div>

                <div class="warning-box">
                    <h4><i class="fas fa-exclamation-triangle"></i> Write Operation Warnings</h4>
                    <p><strong>Data Loss Prevention:</strong> Always use try-with-resources or explicit close() calls</p>
                    <p><strong>Atomicity:</strong> Use temp files and atomic moves for critical data</p>
                    <p><strong>Buffer Flushing:</strong> Call flush() before closing for buffered streams</p>
                </div>
            </div>
        </div>

        <!-- Chapter 6: Serialization -->
        <div id="serialization" class="chapter">
            <h2 class="chapter-title">6. Serialization & Deserialization - Complete Guide</h2>
            <div class="chapter-content">
                <p>Serialization converts objects to byte streams for storage or transmission. While Java's built-in serialization exists, modern alternatives offer better performance, security, and cross-platform compatibility.</p>

                <h3 class="section-title">Serialization Methods Comparison</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Method</th>
                                <th>Pros</th>
                                <th>Cons</th>
                                <th>Use Cases</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Java Serialization</td>
                                <td>Built-in, easy to use</td>
                                <td>Security risks, version issues</td>
                                <td>Legacy systems, quick prototyping</td>
                            </tr>
                            <tr>
                                <td>JSON (Jackson/Gson)</td>
                                <td>Human-readable, cross-platform</td>
                                <td>Larger size, slower</td>
                                <td>APIs, configuration, web services</td>
                            </tr>
                            <tr>
                                <td>Protocol Buffers</td>
                                <td>Compact, fast, versioning</td>
                                <td>Requires schema, complexity</td>
                                <td>Microservices, gRPC, performance</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3 class="section-title">Java Serialization Implementation</h3>
                <div class="code-block">
                    <div class="code-title"><i class="fab fa-java"></i> Advanced Serialization</div>
                    <pre><span class="keyword">import</span> java.io.*;

<span class="keyword">class</span> <span class="type">Person</span> <span class="keyword">implements</span> <span class="type">Serializable</span> {
    <span class="keyword">private static final long</span> serialVersionUID = <span class="number">1L</span>;
    <span class="keyword">private</span> <span class="type">String</span> name;
    <span class="keyword">private</span> <span class="keyword">int</span> age;
    <span class="keyword">private transient</span> <span class="type">String</span> password; <span class="comment">// Won't be serialized</span>
    
    <span class="comment">// Custom serialization logic</span>
    <span class="keyword">private void</span> writeObject(<span class="type">ObjectOutputStream</span> oos) 
            <span class="keyword">throws</span> <span class="type">IOException</span> {
        oos.defaultWriteObject();
        oos.writeObject(encrypt(password));
    }
}

<span class="keyword">public class</span> <span class="type">SerializationExample</span> {
    <span class="keyword">public static void</span> serializeObject(<span class="type">Object</span> obj, <span class="type">String</span> filename) 
            <span class="keyword">throws</span> <span class="type">IOException</span> {
        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> oos = <span class="keyword">new</span> <span class="type">ObjectOutputStream</span>(
                <span class="keyword">new</span> <span class="type">FileOutputStream</span>(filename))) {
            oos.writeObject(obj);
        }
    }
    
    <span class="keyword">public static</span> &lt;<span class="type">T</span>&gt; <span class="type">T</span> deserializeObject(<span class="type">String</span> filename, <span class="type">Class</span>&lt;<span class="type">T</span>&gt; clazz) 
            <span class="keyword">throws</span> <span class="type">IOException</span>, <span class="type">ClassNotFoundException</span> {
        <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> ois = <span class="keyword">new</span> <span class="type">ObjectInputStream</span>(
                <span class="keyword">new</span> <span class="type">FileInputStream</span>(filename))) {
            <span class="keyword">return</span> clazz.cast(ois.readObject());
        }
    }
}</pre>
                </div>

                <h3 class="section-title">JSON Serialization - Modern Approach</h3>
                <div class="code-block">
                    <div class="code-title"><i class="fab fa-java"></i> JSON with Gson</div>
                    <pre><span class="keyword">import</span> com.google.gson.*;

<span class="keyword">public class</span> <span class="type">JsonSerialization</span> {
    <span class="keyword">private static final</span> <span class="type">Gson</span> gson = <span class="keyword">new</span> <span class="type">GsonBuilder</span>()
        .setPrettyPrinting()
        .create();
    
    <span class="keyword">public static void</span> serializeToJson(<span class="type">Object</span> obj, <span class="type">String</span> filename) 
            <span class="keyword">throws</span> <span class="type">IOException</span> {
        <span class="type">String</span> json = gson.toJson(obj);
        <span class="type">Files</span>.writeString(<span class="type">Path</span>.of(filename), json);
    }
    
    <span class="keyword">public static</span> &lt;<span class="type">T</span>&gt; <span class="type">T</span> deserializeFromJson(<span class="type">String</span> filename, <span class="type">Class</span>&lt;<span class="type">T</span>&gt; clazz) 
            <span class="keyword">throws</span> <span class="type">IOException</span> {
        <span class="type">String</span> json = <span class="type">Files</span>.readString(<span class="type">Path</span>.of(filename));
        <span class="keyword">return</span> gson.fromJson(json, clazz);
    }
}</pre>
                </div>

                <div class="warning-box">
                    <h4><i class="fas fa-shield-alt"></i> Security Best Practices</h4>
                    <p><strong>Never deserialize untrusted data</strong> - Java serialization has known vulnerabilities</p>
                    <p><strong>Use allowlists</strong> - Validate class types before deserialization</p>
                    <p><strong>Prefer JSON/XML</strong> - More secure for external data exchange</p>
                </div>
            </div>
        </div>

        <!-- Chapter 7: Advanced Operations -->
        <div id="advanced-operations" class="chapter">
            <h2 class="chapter-title">7. Advanced File Operations</h2>
            <div class="chapter-content">

                <h3 class="section-title">File Watching Service</h3>
                <div class="code-block">
                    <div class="code-title"><i class="fab fa-java"></i> Monitor Directory Changes</div>
                    <pre><span class="keyword">import</span> java.nio.file.*;

<span class="keyword">public class</span> <span class="type">FileWatcher</span> {
    <span class="keyword">public static void</span> watchDirectory(<span class="type">Path</span> dir) <span class="keyword">throws</span> <span class="type">Exception</span> {
        <span class="type">WatchService</span> watcher = <span class="type">FileSystems</span>.getDefault().newWatchService();
        dir.register(watcher, 
            <span class="type">StandardWatchEventKinds</span>.ENTRY_CREATE,
            <span class="type">StandardWatchEventKinds</span>.ENTRY_MODIFY,
            <span class="type">StandardWatchEventKinds</span>.ENTRY_DELETE);
        
        <span class="keyword">while</span> (<span class="keyword">true</span>) {
            <span class="type">WatchKey</span> key = watcher.take();
            <span class="keyword">for</span> (<span class="type">WatchEvent</span>&lt;?&gt; event : key.pollEvents()) {
                <span class="type">Path</span> changed = (<span class="type">Path</span>) event.context();
                System.out.println(event.kind() + <span class="string">": "</span> + changed);
            }
            key.reset();
        }
    }
}</pre>
                </div>

                <h3 class="section-title">Walking File Trees</h3>
                <div class="code-block">
                    <div class="code-title"><i class="fab fa-java"></i> Directory Traversal</div>
                    <pre><span class="comment">// Find all Java files</span>
<span class="type">Files</span>.walk(<span class="type">Path</span>.of(<span class="string">"src"</span>))
     .filter(p -> p.toString().endsWith(<span class="string">".java"</span>))
     .forEach(<span class="type">System</span>.out::println);

<span class="comment">// Copy directory recursively</span>
<span class="type">Files</span>.walk(source)
     .forEach(src -> {
         <span class="type">Path</span> dest = target.resolve(source.relativize(src));
         <span class="keyword">try</span> {
             <span class="type">Files</span>.copy(src, dest, <span class="type">StandardCopyOption</span>.REPLACE_EXISTING);
         } <span class="keyword">catch</span> (<span class="type">IOException</span> e) { }
     });</pre>
                </div>

                <h3 class="section-title">Memory-Mapped Files</h3>
                <div class="code-block">
                    <div class="code-title"><i class="fab fa-java"></i> High-Performance I/O</div>
                    <pre><span class="keyword">try</span> (<span class="type">FileChannel</span> channel = <span class="type">FileChannel</span>.open(<span class="type">Path</span>.of(<span class="string">"large.dat"</span>))) {
    <span class="keyword">long</span> size = channel.size();
    <span class="type">MappedByteBuffer</span> buffer = channel.map(
        <span class="type">FileChannel</span>.MapMode.READ_WRITE, <span class="number">0</span>, size);
    
    <span class="comment">// Direct memory access - fastest I/O</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {
        buffer.putInt(i * <span class="number">4</span>, i);
    }
    buffer.force(); <span class="comment">// Flush to disk</span>
}</pre>
                </div>

                <h3 class="section-title">File Comparison</h3>
                <div class="code-block">
                    <div class="code-title"><i class="fab fa-java"></i> Compare Files</div>
                    <pre><span class="comment">// Check if same file</span>
<span class="keyword">boolean</span> same = <span class="type">Files</span>.isSameFile(path1, path2);

<span class="comment">// Find first mismatch (Java 12+)</span>
<span class="keyword">long</span> mismatch = <span class="type">Files</span>.mismatch(path1, path2); <span class="comment">// -1 if identical</span>

<span class="comment">// Content comparison</span>
<span class="keyword">byte</span>[] bytes1 = <span class="type">Files</span>.readAllBytes(path1);
<span class="keyword">byte</span>[] bytes2 = <span class="type">Files</span>.readAllBytes(path2);
<span class="keyword">boolean</span> equal = <span class="type">Arrays</span>.equals(bytes1, bytes2);</pre>
                </div>
            </div>
        </div>

        <!-- Chapter 8: Best Practices -->
        <div id="best-practices" class="chapter">
            <h2 class="chapter-title">8. Best Practices & Performance</h2>
            <div class="chapter-content">

                <h3 class="section-title">Critical Best Practices</h3>
                <div class="highlight-box">
                    <h4><i class="fas fa-check-circle"></i> Essential Guidelines</h4>
                    <ul>
                        <li><strong>Always use try-with-resources</strong> - Automatic cleanup prevents leaks</li>
                        <li><strong>Specify charset explicitly</strong> - Use StandardCharsets.UTF_8</li>
                        <li><strong>Use NIO.2 for new code</strong> - Path/Files > File class</li>
                        <li><strong>Buffer your streams</strong> - Wrap with Buffered* classes</li>
                        <li><strong>Check file existence before operations</strong> - Prevent exceptions</li>
                        <li><strong>Validate user input paths</strong> - Prevent directory traversal attacks</li>
                    </ul>
                </div>

                <h3 class="section-title">Performance Optimization</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Operation</th>
                                <th>Best Choice</th>
                                <th>Performance Tip</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Small text (&lt;100MB)</td>
                                <td>Files.readString()</td>
                                <td>Fastest for one-time read</td>
                            </tr>
                            <tr>
                                <td>Large text (>100MB)</td>
                                <td>Files.lines()</td>
                                <td>Stream for memory efficiency</td>
                            </tr>
                            <tr>
                                <td>Binary files</td>
                                <td>FileChannel</td>
                                <td>Use direct buffers (64KB)</td>
                            </tr>
                            <tr>
                                <td>Sequential access</td>
                                <td>BufferedReader/Writer</td>
                                <td>8KB-64KB buffer size</td>
                            </tr>
                            <tr>
                                <td>Random access</td>
                                <td>Memory-mapped</td>
                                <td>Best for large files</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3 class="section-title">Quick Reference</h3>
                <div class="code-block">
                    <div class="code-title"><i class="fab fa-java"></i> Common Operations Cheat Sheet</div>
                    <pre><span class="comment">// READ</span>
<span class="type">String</span> content = <span class="type">Files</span>.readString(<span class="type">Path</span>.of(<span class="string">"file.txt"</span>));
<span class="type">List</span>&lt;<span class="type">String</span>&gt; lines = <span class="type">Files</span>.readAllLines(<span class="type">Path</span>.of(<span class="string">"file.txt"</span>));
<span class="keyword">byte</span>[] bytes = <span class="type">Files</span>.readAllBytes(<span class="type">Path</span>.of(<span class="string">"file.bin"</span>));

<span class="comment">// WRITE</span>
<span class="type">Files</span>.writeString(<span class="type">Path</span>.of(<span class="string">"out.txt"</span>), <span class="string">"content"</span>);
<span class="type">Files</span>.write(<span class="type">Path</span>.of(<span class="string">"out.txt"</span>), lines);
<span class="type">Files</span>.write(<span class="type">Path</span>.of(<span class="string">"out.bin"</span>), bytes);

<span class="comment">// COPY/MOVE/DELETE</span>
<span class="type">Files</span>.copy(source, target, <span class="type">StandardCopyOption</span>.REPLACE_EXISTING);
<span class="type">Files</span>.move(source, target, <span class="type">StandardCopyOption</span>.ATOMIC_MOVE);
<span class="type">Files</span>.delete(path);</pre>
                </div>

                <div class="summary-grid">
                    <div class="summary-card">
                        <h4>Memory Efficiency</h4>
                        <ul>
                            <li>Use streams for large files</li>
                            <li>Direct buffers for binary I/O</li>
                            <li>Memory-mapped for >1GB files</li>
                        </ul>
                    </div>
                    <div class="summary-card">
                        <h4>Security</h4>
                        <ul>
                            <li>Validate all file paths</li>
                            <li>Use secure temp directories</li>
                            <li>Avoid Java serialization</li>
                        </ul>
                    </div>
                    <div class="summary-card">
                        <h4>Reliability</h4>
                        <ul>
                            <li>Handle all IOExceptions</li>
                            <li>Use atomic operations</li>
                            <li>Implement retry logic</li>
                        </ul>
                    </div>
                </div>

                <div class="final-message">
                    <h3>Master Java File I/O!</h3>
                    <p>Choose the right tool, write efficient code, handle errors gracefully</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Footer Section -->
    <footer class="footer">
        <div id="footer-placeholder"></div>
    </footer>

    <script>
        fetch("/footer.html")
            .then(res => res.text())
            .then(data => {
                document.getElementById("footer-placeholder").innerHTML = data;
            });
    </script>
    <script src="/js/footer.js"></script>
    <script src="/js/reading-progress.js"></script>
    <script src="/js/file-io-guide.js"></script>
</body>

</html>