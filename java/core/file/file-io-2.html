<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Advanced Java File I/O techniques including writing files, serialization, file watching, and performance optimization">
    <title>Java File I/O Part 2 - GyanCode</title>
    <link rel="icon" type="image/png" href="/assets/images/logo.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="/css/base.css">
    <link rel="stylesheet" href="/css/components.css">
    <link rel="stylesheet" href="/css/layout.css">
    <link rel="stylesheet" href="/css/pages.css">
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>
    <aside class="sidebar" id="sidebar"></aside>
    <div class="sidebar-overlay"></div>
    <main class="page-content" id="main-content">
        <div class="reading-progress" id="reading-progress"></div>
        <div class="content-wrapper">
            <nav class="breadcrumb" id="breadcrumb"></nav>
            <article class="article-container">
                <header class="article-header">
                    <h1 class="article-title">Java File I/O Part 2</h1>
                    <p class="article-subtitle">Advanced writing, serialization, file watching, and performance optimization techniques</p>
                    <div class="article-meta">
                        <span><i class="fas fa-clock"></i> 20 min read</span>
                        <span><i class="fas fa-signal"></i> Intermediate</span>
                    </div>
                </header>
                <nav class="toc" id="toc"></nav>
                <div class="article-body">
                    <!-- Chapter 5: Writing Files -->
                    <section id="writing-files" class="chapter">
                        <h2 class="chapter-title">Writing Files Efficiently</h2>
                        <div class="chapter-content">
                            <p>Modern Java provides multiple efficient ways to write files, each optimized for different scenarios. Choose wisely based on file size, content type, and performance requirements.</p>

                            <h3>Writing Strategies - Complete Guide</h3>
                            <div class="info-box">
                                <h4><i class="fas fa-pencil-alt"></i> When to Use Each Writing Method</h4>
                                <ul>
                                    <li><strong>Files.writeString():</strong> Small text content, single write operation (Java 11+)</li>
                                    <li><strong>Files.write():</strong> Writing byte arrays or lists of strings</li>
                                    <li><strong>BufferedWriter:</strong> Multiple write operations, append mode, large text</li>
                                    <li><strong>PrintWriter:</strong> Formatted output, printing methods</li>
                                    <li><strong>FileChannel:</strong> Large binary files, async I/O, high performance</li>
                                    <li><strong>DataOutputStream:</strong> Writing primitive data types</li>
                                </ul>
                            </div>

                            <h3>Text File Writing - Comprehensive Examples</h3>
                            <div class="code-block">
                                <div class="code-header">Complete Text Writing Solutions</div>
                                <pre><code><span class="keyword">import</span> java.nio.file.*;
<span class="keyword">import</span> java.io.*;
<span class="keyword">import</span> java.util.*;

<span class="keyword">public class</span> TextFileWriting {

    <span class="comment">// Method 1: Write String directly (Java 11+)</span>
    <span class="keyword">public static void</span> writeString(String filename, String content)
            <span class="keyword">throws</span> IOException {
        Files.writeString(Path.of(filename), content,
            StandardCharsets.UTF_8);
    }

    <span class="comment">// Method 2: BufferedWriter for incremental writing</span>
    <span class="keyword">public static void</span> writeWithBufferedWriter(String filename)
            <span class="keyword">throws</span> IOException {
        <span class="keyword">try</span> (BufferedWriter writer = Files.newBufferedWriter(
                Path.of(filename), StandardCharsets.UTF_8)) {

            writer.write(<span class="string">"Header Line"</span>);
            writer.newLine();

            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {
                writer.write(<span class="string">"Data line "</span> + i);
                writer.newLine();
            }
            writer.flush();
        }
    }

    <span class="comment">// Method 3: Atomic write operation</span>
    <span class="keyword">public static void</span> writeAtomic(String filename, String content)
            <span class="keyword">throws</span> IOException {
        Path target = Path.of(filename);
        Path temp = Files.createTempFile(<span class="string">"temp"</span>, <span class="string">".tmp"</span>);

        <span class="keyword">try</span> {
            Files.writeString(temp, content);
            Files.move(temp, target, StandardCopyOption.ATOMIC_MOVE);
        } <span class="keyword">finally</span> {
            Files.deleteIfExists(temp);
        }
    }
}</code></pre>
                            </div>

                            <h3>Performance Comparison</h3>
                            <div class="feature-grid">
                                <div class="card">
                                    <h4>Files.writeString()</h4>
                                    <p><strong>Use Case:</strong> Small text files</p>
                                    <p><strong>Performance:</strong> Fast</p>
                                </div>
                                <div class="card">
                                    <h4>BufferedWriter</h4>
                                    <p><strong>Use Case:</strong> Large text files</p>
                                    <p><strong>Performance:</strong> Efficient</p>
                                </div>
                                <div class="card">
                                    <h4>Memory-Mapped</h4>
                                    <p><strong>Use Case:</strong> Large binary files</p>
                                    <p><strong>Performance:</strong> Fastest</p>
                                </div>
                            </div>

                            <div class="info-box">
                                <h4><i class="fas fa-exclamation-triangle"></i> Write Operation Warnings</h4>
                                <p><strong>Data Loss Prevention:</strong> Always use try-with-resources or explicit close() calls</p>
                                <p><strong>Atomicity:</strong> Use temp files and atomic moves for critical data</p>
                                <p><strong>Buffer Flushing:</strong> Call flush() before closing for buffered streams</p>
                            </div>
                        </div>
                    </section>

                    <!-- Chapter 6: Serialization -->
                    <section id="serialization" class="chapter">
                        <h2 class="chapter-title">Serialization and Deserialization - Complete Guide</h2>
                        <div class="chapter-content">
                            <p>Serialization converts objects to byte streams for storage or transmission. While Java's built-in serialization exists, modern alternatives offer better performance, security, and cross-platform compatibility.</p>

                            <h3>Serialization Methods Comparison</h3>
                            <div class="table-container">
                                <table>
                                    <thead>
                                        <tr>
                                            <th>Method</th>
                                            <th>Pros</th>
                                            <th>Cons</th>
                                            <th>Use Cases</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>Java Serialization</td>
                                            <td>Built-in, easy to use</td>
                                            <td>Security risks, version issues</td>
                                            <td>Legacy systems, quick prototyping</td>
                                        </tr>
                                        <tr>
                                            <td>JSON (Jackson/Gson)</td>
                                            <td>Human-readable, cross-platform</td>
                                            <td>Larger size, slower</td>
                                            <td>APIs, configuration, web services</td>
                                        </tr>
                                        <tr>
                                            <td>Protocol Buffers</td>
                                            <td>Compact, fast, versioning</td>
                                            <td>Requires schema, complexity</td>
                                            <td>Microservices, gRPC, performance</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>

                            <h3>Java Serialization Implementation</h3>
                            <div class="code-block">
                                <div class="code-header">Advanced Serialization</div>
                                <pre><code><span class="keyword">import</span> java.io.*;

<span class="keyword">class</span> Person <span class="keyword">implements</span> Serializable {
    <span class="keyword">private static final long</span> serialVersionUID = <span class="number">1L</span>;
    <span class="keyword">private</span> String name;
    <span class="keyword">private</span> <span class="keyword">int</span> age;
    <span class="keyword">private transient</span> String password; <span class="comment">// Won't be serialized</span>

    <span class="comment">// Custom serialization logic</span>
    <span class="keyword">private void</span> writeObject(ObjectOutputStream oos)
            <span class="keyword">throws</span> IOException {
        oos.defaultWriteObject();
        oos.writeObject(encrypt(password));
    }
}

<span class="keyword">public class</span> SerializationExample {
    <span class="keyword">public static void</span> serializeObject(Object obj, String filename)
            <span class="keyword">throws</span> IOException {
        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(
                <span class="keyword">new</span> FileOutputStream(filename))) {
            oos.writeObject(obj);
        }
    }

    <span class="keyword">public static</span> &lt;T&gt; T deserializeObject(String filename, Class&lt;T&gt; clazz)
            <span class="keyword">throws</span> IOException, ClassNotFoundException {
        <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(
                <span class="keyword">new</span> FileInputStream(filename))) {
            <span class="keyword">return</span> clazz.cast(ois.readObject());
        }
    }
}</code></pre>
                            </div>

                            <h3>JSON Serialization - Modern Approach</h3>
                            <div class="code-block">
                                <div class="code-header">JSON with Gson</div>
                                <pre><code><span class="keyword">import</span> com.google.gson.*;

<span class="keyword">public class</span> JsonSerialization {
    <span class="keyword">private static final</span> Gson gson = <span class="keyword">new</span> GsonBuilder()
        .setPrettyPrinting()
        .create();

    <span class="keyword">public static void</span> serializeToJson(Object obj, String filename)
            <span class="keyword">throws</span> IOException {
        String json = gson.toJson(obj);
        Files.writeString(Path.of(filename), json);
    }

    <span class="keyword">public static</span> &lt;T&gt; T deserializeFromJson(String filename, Class&lt;T&gt; clazz)
            <span class="keyword">throws</span> IOException {
        String json = Files.readString(Path.of(filename));
        <span class="keyword">return</span> gson.fromJson(json, clazz);
    }
}</code></pre>
                            </div>

                            <div class="info-box">
                                <h4><i class="fas fa-shield-alt"></i> Security Best Practices</h4>
                                <p><strong>Never deserialize untrusted data</strong> - Java serialization has known vulnerabilities</p>
                                <p><strong>Use allowlists</strong> - Validate class types before deserialization</p>
                                <p><strong>Prefer JSON/XML</strong> - More secure for external data exchange</p>
                            </div>
                        </div>
                    </section>

                    <!-- Chapter 7: Advanced Operations -->
                    <section id="advanced-operations" class="chapter">
                        <h2 class="chapter-title">Advanced File Operations</h2>
                        <div class="chapter-content">

                            <h3>File Watching Service</h3>
                            <div class="code-block">
                                <div class="code-header">Monitor Directory Changes</div>
                                <pre><code><span class="keyword">import</span> java.nio.file.*;

<span class="keyword">public class</span> FileWatcher {
    <span class="keyword">public static void</span> watchDirectory(Path dir) <span class="keyword">throws</span> Exception {
        WatchService watcher = FileSystems.getDefault().newWatchService();
        dir.register(watcher,
            StandardWatchEventKinds.ENTRY_CREATE,
            StandardWatchEventKinds.ENTRY_MODIFY,
            StandardWatchEventKinds.ENTRY_DELETE);

        <span class="keyword">while</span> (<span class="keyword">true</span>) {
            WatchKey key = watcher.take();
            <span class="keyword">for</span> (WatchEvent&lt;?&gt; event : key.pollEvents()) {
                Path changed = (Path) event.context();
                System.out.println(event.kind() + <span class="string">": "</span> + changed);
            }
            key.reset();
        }
    }
}</code></pre>
                            </div>

                            <h3>Walking File Trees</h3>
                            <div class="code-block">
                                <div class="code-header">Directory Traversal</div>
                                <pre><code><span class="comment">// Find all Java files</span>
Files.walk(Path.of(<span class="string">"src"</span>))
     .filter(p -&gt; p.toString().endsWith(<span class="string">".java"</span>))
     .forEach(System.out::println);

<span class="comment">// Copy directory recursively</span>
Files.walk(source)
     .forEach(src -&gt; {
         Path dest = target.resolve(source.relativize(src));
         <span class="keyword">try</span> {
             Files.copy(src, dest, StandardCopyOption.REPLACE_EXISTING);
         } <span class="keyword">catch</span> (IOException e) { }
     });</code></pre>
                            </div>

                            <h3>Memory-Mapped Files</h3>
                            <div class="code-block">
                                <div class="code-header">High-Performance I/O</div>
                                <pre><code><span class="keyword">try</span> (FileChannel channel = FileChannel.open(Path.of(<span class="string">"large.dat"</span>))) {
    <span class="keyword">long</span> size = channel.size();
    MappedByteBuffer buffer = channel.map(
        FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, size);

    <span class="comment">// Direct memory access - fastest I/O</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {
        buffer.putInt(i * <span class="number">4</span>, i);
    }
    buffer.force(); <span class="comment">// Flush to disk</span>
}</code></pre>
                            </div>

                            <h3>File Comparison</h3>
                            <div class="code-block">
                                <div class="code-header">Compare Files</div>
                                <pre><code><span class="comment">// Check if same file</span>
<span class="keyword">boolean</span> same = Files.isSameFile(path1, path2);

<span class="comment">// Find first mismatch (Java 12+)</span>
<span class="keyword">long</span> mismatch = Files.mismatch(path1, path2); <span class="comment">// -1 if identical</span>

<span class="comment">// Content comparison</span>
<span class="keyword">byte</span>[] bytes1 = Files.readAllBytes(path1);
<span class="keyword">byte</span>[] bytes2 = Files.readAllBytes(path2);
<span class="keyword">boolean</span> equal = Arrays.equals(bytes1, bytes2);</code></pre>
                            </div>
                        </div>
                    </section>

                    <!-- Chapter 8: Best Practices -->
                    <section id="best-practices" class="chapter">
                        <h2 class="chapter-title">Best Practices and Performance</h2>
                        <div class="chapter-content">

                            <h3>Critical Best Practices</h3>
                            <div class="highlight-box">
                                <h4><i class="fas fa-check-circle"></i> Essential Guidelines</h4>
                                <ul>
                                    <li><strong>Always use try-with-resources</strong> - Automatic cleanup prevents leaks</li>
                                    <li><strong>Specify charset explicitly</strong> - Use StandardCharsets.UTF_8</li>
                                    <li><strong>Use NIO.2 for new code</strong> - Path/Files > File class</li>
                                    <li><strong>Buffer your streams</strong> - Wrap with Buffered* classes</li>
                                    <li><strong>Check file existence before operations</strong> - Prevent exceptions</li>
                                    <li><strong>Validate user input paths</strong> - Prevent directory traversal attacks</li>
                                </ul>
                            </div>

                            <h3>Performance Optimization</h3>
                            <div class="table-container">
                                <table>
                                    <thead>
                                        <tr>
                                            <th>Operation</th>
                                            <th>Best Choice</th>
                                            <th>Performance Tip</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>Small text (&lt;100MB)</td>
                                            <td>Files.readString()</td>
                                            <td>Fastest for one-time read</td>
                                        </tr>
                                        <tr>
                                            <td>Large text (&gt;100MB)</td>
                                            <td>Files.lines()</td>
                                            <td>Stream for memory efficiency</td>
                                        </tr>
                                        <tr>
                                            <td>Binary files</td>
                                            <td>FileChannel</td>
                                            <td>Use direct buffers (64KB)</td>
                                        </tr>
                                        <tr>
                                            <td>Sequential access</td>
                                            <td>BufferedReader/Writer</td>
                                            <td>8KB-64KB buffer size</td>
                                        </tr>
                                        <tr>
                                            <td>Random access</td>
                                            <td>Memory-mapped</td>
                                            <td>Best for large files</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>

                            <h3>Quick Reference</h3>
                            <div class="code-block">
                                <div class="code-header">Common Operations Cheat Sheet</div>
                                <pre><code><span class="comment">// READ</span>
String content = Files.readString(Path.of(<span class="string">"file.txt"</span>));
List&lt;String&gt; lines = Files.readAllLines(Path.of(<span class="string">"file.txt"</span>));
<span class="keyword">byte</span>[] bytes = Files.readAllBytes(Path.of(<span class="string">"file.bin"</span>));

<span class="comment">// WRITE</span>
Files.writeString(Path.of(<span class="string">"out.txt"</span>), <span class="string">"content"</span>);
Files.write(Path.of(<span class="string">"out.txt"</span>), lines);
Files.write(Path.of(<span class="string">"out.bin"</span>), bytes);

<span class="comment">// COPY/MOVE/DELETE</span>
Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);
Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);
Files.delete(path);</code></pre>
                            </div>

                            <div class="feature-grid">
                                <div class="card">
                                    <h4>Memory Efficiency</h4>
                                    <ul>
                                        <li>Use streams for large files</li>
                                        <li>Direct buffers for binary I/O</li>
                                        <li>Memory-mapped for &gt;1GB files</li>
                                    </ul>
                                </div>
                                <div class="card">
                                    <h4>Security</h4>
                                    <ul>
                                        <li>Validate all file paths</li>
                                        <li>Use secure temp directories</li>
                                        <li>Avoid Java serialization</li>
                                    </ul>
                                </div>
                                <div class="card">
                                    <h4>Reliability</h4>
                                    <ul>
                                        <li>Handle all IOExceptions</li>
                                        <li>Use atomic operations</li>
                                        <li>Implement retry logic</li>
                                    </ul>
                                </div>
                            </div>

                            <div class="highlight-box">
                                <h4><i class="fas fa-trophy"></i> Master Java File I/O</h4>
                                <p>Choose the right tool, write efficient code, handle errors gracefully</p>
                            </div>
                        </div>
                    </section>
                </div>
                <footer class="article-nav">
                    <a href="file-io.html" class="nav-link prev">
                        <span>Previous</span>
                        <span>Java File I/O Part 1</span>
                    </a>
                </footer>
            </article>
        </div>
    </main>
    <footer class="site-footer" id="site-footer"></footer>
    <button class="back-to-top" id="back-to-top" type="button" aria-label="Back to top"><i class="fas fa-chevron-up"></i></button>
    <script src="/js/navigation-data.js"></script>
    <script src="/js/components.js"></script>
</body>
</html>
