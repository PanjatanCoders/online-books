<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Complete guide to Java Multithreading - Learn thread creation, synchronization, concurrent collections, and best practices">
    <title>Java Multithreading - TechTok Cafe</title>
    <link rel="icon" type="image/png" href="/assets/images/logo.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="/css/base.css">
    <link rel="stylesheet" href="/css/components.css">
    <link rel="stylesheet" href="/css/layout.css">
    <link rel="stylesheet" href="/css/pages.css">
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>
    <aside class="sidebar" id="sidebar"></aside>
    <div class="sidebar-overlay"></div>
    <main class="page-content" id="main-content">
        <div class="reading-progress" id="reading-progress"></div>
        <div class="content-wrapper">
            <nav class="breadcrumb" id="breadcrumb"></nav>
            <article class="article-container">
                <header class="article-header">
                    <h1 class="article-title">Java Multithreading Mastery</h1>
                    <p class="article-subtitle">Complete guide to concurrent programming in Java - from basics to advanced patterns</p>
                    <div class="article-meta">
                        <span><i class="fas fa-clock"></i> 35 min read</span>
                        <span><i class="fas fa-signal"></i> Advanced</span>
                    </div>
                </header>

                <nav class="toc" id="toc"></nav>

                <div class="article-body">
                    <!-- Section 1: Introduction -->
                    <section id="introduction" class="chapter">
                        <h2 class="chapter-title">1. Introduction to Multithreading</h2>
                        <div class="chapter-content">
                            <div class="info-box">
                                <h4><i class="fas fa-info-circle"></i> What is Multithreading?</h4>
                                <p>Multithreading enables a program to execute multiple threads concurrently, improving performance through parallel execution and better resource utilization. It allows applications to perform multiple tasks simultaneously rather than sequentially.</p>
                            </div>

                            <div class="feature-grid">
                                <div class="card">
                                    <h4>Single-Threaded Execution</h4>
                                    <ul>
                                        <li>Tasks execute one after another</li>
                                        <li>CPU cores underutilized</li>
                                        <li>Blocking operations halt entire program</li>
                                        <li>Predictable but slow performance</li>
                                        <li>Simple to debug and understand</li>
                                    </ul>
                                </div>
                                <div class="card">
                                    <h4>Multi-Threaded Execution</h4>
                                    <ul>
                                        <li>Tasks execute concurrently</li>
                                        <li>Better CPU utilization across cores</li>
                                        <li>Non-blocking operations possible</li>
                                        <li>Complex but efficient performance</li>
                                        <li>Requires careful synchronization</li>
                                    </ul>
                                </div>
                            </div>

                            <div class="code-block">
                                <div class="code-header">
                                    <span><i class="fab fa-java"></i> Sequential vs Concurrent Execution</span>
                                </div>
                                <pre><code><span class="comment">// Sequential execution example</span>
<span class="keyword">public class</span> <span class="type">SequentialExample</span> {
    <span class="keyword">public static void</span> main(<span class="type">String</span>[] args) {
        <span class="keyword">long</span> start = System.currentTimeMillis();

        <span class="comment">// Task 1 - takes 3 seconds</span>
        performTask(<span class="string">"Database Operation"</span>, <span class="number">3000</span>);

        <span class="comment">// Task 2 - takes 2 seconds</span>
        performTask(<span class="string">"File Processing"</span>, <span class="number">2000</span>);

        <span class="comment">// Task 3 - takes 1 second</span>
        performTask(<span class="string">"Network Call"</span>, <span class="number">1000</span>);

        <span class="keyword">long</span> end = System.currentTimeMillis();
        System.out.println(<span class="string">"Total time: "</span> + (end - start) + <span class="string">"ms"</span>);
        <span class="comment">// Output: Total time: ~6000ms</span>
    }

    <span class="keyword">static void</span> performTask(<span class="type">String</span> taskName, <span class="keyword">int</span> duration) {
        System.out.println(<span class="string">"Starting "</span> + taskName);
        <span class="keyword">try</span> {
            Thread.sleep(duration);
        } <span class="keyword">catch</span> (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        System.out.println(<span class="string">"Completed "</span> + taskName);
    }
}

<span class="comment">// Concurrent execution example</span>
<span class="keyword">public class</span> <span class="type">ConcurrentExample</span> {
    <span class="keyword">public static void</span> main(<span class="type">String</span>[] args) <span class="keyword">throws</span> InterruptedException {
        <span class="keyword">long</span> start = System.currentTimeMillis();

        <span class="comment">// Create threads for each task</span>
        <span class="type">Thread</span> task1 = <span class="keyword">new</span> <span class="type">Thread</span>(() -> performTask(<span class="string">"Database Operation"</span>, <span class="number">3000</span>));
        <span class="type">Thread</span> task2 = <span class="keyword">new</span> <span class="type">Thread</span>(() -> performTask(<span class="string">"File Processing"</span>, <span class="number">2000</span>));
        <span class="type">Thread</span> task3 = <span class="keyword">new</span> <span class="type">Thread</span>(() -> performTask(<span class="string">"Network Call"</span>, <span class="number">1000</span>));

        <span class="comment">// Start all threads simultaneously</span>
        task1.start();
        task2.start();
        task3.start();

        <span class="comment">// Wait for all to complete</span>
        task1.join();
        task2.join();
        task3.join();

        <span class="keyword">long</span> end = System.currentTimeMillis();
        System.out.println(<span class="string">"Total time: "</span> + (end - start) + <span class="string">"ms"</span>);
        <span class="comment">// Output: Total time: ~3000ms (limited by slowest task)</span>
    }
}</code></pre>
                            </div>

                            <div class="feature-grid">
                                <div class="card">
                                    <h4>Benefits of Multithreading</h4>
                                    <ul>
                                        <li>Improved application responsiveness</li>
                                        <li>Better resource utilization</li>
                                        <li>Concurrent task execution</li>
                                        <li>Enhanced user experience</li>
                                        <li>Scalability on multi-core systems</li>
                                    </ul>
                                </div>
                                <div class="card">
                                    <h4>Common Use Cases</h4>
                                    <ul>
                                        <li>GUI applications (UI + background tasks)</li>
                                        <li>Web servers (handling multiple requests)</li>
                                        <li>Data processing pipelines</li>
                                        <li>Producer-consumer scenarios</li>
                                        <li>Parallel algorithms</li>
                                    </ul>
                                </div>
                                <div class="card">
                                    <h4>Challenges to Consider</h4>
                                    <ul>
                                        <li>Race conditions and data corruption</li>
                                        <li>Deadlocks and livelocks</li>
                                        <li>Resource contention</li>
                                        <li>Debugging complexity</li>
                                        <li>Memory consistency issues</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </section>

                    <!-- Section 2: Threading Basics -->
                    <section id="basics" class="chapter">
                        <h2 class="chapter-title">2. Threading Basics</h2>
                        <div class="chapter-content">
                            <div class="info-box">
                                <h4><i class="fas fa-book"></i> Core Threading Concepts</h4>
                                <p>Understanding fundamental concepts like processes vs threads, thread anatomy, and the Java Thread class is essential for effective concurrent programming.</p>
                            </div>

                            <div class="feature-grid">
                                <div class="card">
                                    <h4>Process vs Thread</h4>
                                    <ul>
                                        <li><strong>Process:</strong> Independent program with own memory space</li>
                                        <li><strong>Thread:</strong> Lightweight process sharing memory within process</li>
                                        <li>Threads share heap memory but have separate stacks</li>
                                        <li>Context switching between threads is faster than processes</li>
                                    </ul>
                                </div>
                                <div class="card">
                                    <h4>Thread Components</h4>
                                    <ul>
                                        <li><strong>Program Counter:</strong> Points to current instruction</li>
                                        <li><strong>Stack:</strong> Local variables and method calls</li>
                                        <li><strong>Registers:</strong> CPU register values</li>
                                        <li><strong>State:</strong> Current execution state</li>
                                        <li><strong>Priority:</strong> Scheduling priority level</li>
                                    </ul>
                                </div>
                                <div class="card">
                                    <h4>Thread Types in Java</h4>
                                    <ul>
                                        <li><strong>User Threads:</strong> Normal application threads</li>
                                        <li><strong>Daemon Threads:</strong> Background service threads</li>
                                        <li><strong>Main Thread:</strong> Entry point of application</li>
                                        <li><strong>Worker Threads:</strong> Execute specific tasks</li>
                                    </ul>
                                </div>
                            </div>

                            <div class="code-block">
                                <div class="code-header">
                                    <span><i class="fab fa-java"></i> Thread Information and Properties</span>
                                </div>
                                <pre><code><span class="keyword">public class</span> <span class="type">ThreadBasicsDemo</span> {
    <span class="keyword">public static void</span> main(<span class="type">String</span>[] args) {
        <span class="comment">// Get information about current thread</span>
        <span class="type">Thread</span> currentThread = Thread.currentThread();

        System.out.println(<span class="string">"=== Current Thread Information ==="</span>);
        System.out.println(<span class="string">"Name: "</span> + currentThread.getName());
        System.out.println(<span class="string">"ID: "</span> + currentThread.getId());
        System.out.println(<span class="string">"Priority: "</span> + currentThread.getPriority());
        System.out.println(<span class="string">"State: "</span> + currentThread.getState());
        System.out.println(<span class="string">"Is Alive: "</span> + currentThread.isAlive());
        System.out.println(<span class="string">"Is Daemon: "</span> + currentThread.isDaemon());

        <span class="comment">// System information</span>
        System.out.println(<span class="string">"\n=== System Information ==="</span>);
        System.out.println(<span class="string">"Available Processors: "</span> +
                         Runtime.getRuntime().availableProcessors());
        System.out.println(<span class="string">"Active Thread Count: "</span> +
                         Thread.activeCount());

        <span class="comment">// Create and examine a custom thread</span>
        <span class="type">Thread</span> customThread = <span class="keyword">new</span> <span class="type">Thread</span>(() -> {
            System.out.println(<span class="string">"\n=== Custom Thread Executing ==="</span>);
            System.out.println(<span class="string">"Custom thread name: "</span> + Thread.currentThread().getName());
            <span class="keyword">try</span> {
                Thread.sleep(<span class="number">2000</span>);
            } <span class="keyword">catch</span> (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            System.out.println(<span class="string">"Custom thread work completed"</span>);
        }, <span class="string">"MyCustomThread"</span>);

        <span class="comment">// Set thread properties</span>
        customThread.setPriority(Thread.NORM_PRIORITY + <span class="number">1</span>);
        customThread.setDaemon(<span class="keyword">false</span>);

        System.out.println(<span class="string">"\n=== Before Start ==="</span>);
        System.out.println(<span class="string">"State: "</span> + customThread.getState());

        customThread.start();

        System.out.println(<span class="string">"\n=== After Start ==="</span>);
        System.out.println(<span class="string">"State: "</span> + customThread.getState());

        <span class="keyword">try</span> {
            customThread.join();
        } <span class="keyword">catch</span> (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        System.out.println(<span class="string">"\n=== After Completion ==="</span>);
        System.out.println(<span class="string">"State: "</span> + customThread.getState());
    }
}</code></pre>
                            </div>

                            <div class="info-box" style="background: linear-gradient(135deg, #ff6b6b22, #feca5722); border-left-color: #ff6b6b;">
                                <h4><i class="fas fa-exclamation-triangle"></i> Important</h4>
                                <p>Never call Thread.stop(), Thread.suspend(), or Thread.resume() as they are deprecated and unsafe. Always use proper interrupt mechanisms and cooperative thread termination.</p>
                            </div>
                        </div>
                    </section>

                    <!-- Section 3: Thread Creation Methods -->
                    <section id="creation" class="chapter">
                        <h2 class="chapter-title">3. Thread Creation Methods</h2>
                        <div class="chapter-content">
                            <div class="info-box">
                                <h4><i class="fas fa-plus-circle"></i> Multiple Approaches to Thread Creation</h4>
                                <p>Java provides several ways to create and manage threads, each with specific advantages and use cases.</p>
                            </div>

                            <div class="code-block">
                                <div class="code-header">
                                    <span><i class="fab fa-java"></i> Method 1: Extending Thread Class</span>
                                </div>
                                <pre><code><span class="keyword">class</span> <span class="type">CustomThread</span> <span class="keyword">extends</span> <span class="type">Thread</span> {
    <span class="keyword">private</span> <span class="type">String</span> taskName;
    <span class="keyword">private</span> <span class="keyword">int</span> iterations;

    <span class="keyword">public</span> CustomThread(<span class="type">String</span> taskName, <span class="keyword">int</span> iterations) {
        <span class="keyword">super</span>(taskName);
        <span class="keyword">this</span>.taskName = taskName;
        <span class="keyword">this</span>.iterations = iterations;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> run() {
        System.out.println(taskName + <span class="string">" started by "</span> + getName());

        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <= iterations; i++) {
            System.out.println(taskName + <span class="string">" - Iteration "</span> + i);
            <span class="keyword">try</span> {
                Thread.sleep(<span class="number">1000</span>);
            } <span class="keyword">catch</span> (InterruptedException e) {
                Thread.currentThread().interrupt();
                <span class="keyword">return</span>;
            }
        }
        System.out.println(taskName + <span class="string">" completed"</span>);
    }
}

<span class="comment">// Usage</span>
<span class="type">CustomThread</span> thread1 = <span class="keyword">new</span> <span class="type">CustomThread</span>(<span class="string">"DataProcessor"</span>, <span class="number">3</span>);
thread1.start();</code></pre>
                            </div>

                            <div class="code-block">
                                <div class="code-header">
                                    <span><i class="fab fa-java"></i> Method 2: Implementing Runnable Interface (Recommended)</span>
                                </div>
                                <pre><code><span class="keyword">class</span> <span class="type">TaskRunner</span> <span class="keyword">implements</span> <span class="type">Runnable</span> {
    <span class="keyword">private</span> <span class="type">String</span> taskName;
    <span class="keyword">private</span> <span class="keyword">int</span> delay;

    <span class="keyword">public</span> TaskRunner(<span class="type">String</span> taskName, <span class="keyword">int</span> delay) {
        <span class="keyword">this</span>.taskName = taskName;
        <span class="keyword">this</span>.delay = delay;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> run() {
        System.out.println(taskName + <span class="string">" started in thread: "</span> +
                         Thread.currentThread().getName());
        <span class="keyword">try</span> {
            Thread.sleep(delay);
            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) {
                <span class="keyword">throw new</span> InterruptedException(<span class="string">"Task was interrupted"</span>);
            }
        } <span class="keyword">catch</span> (InterruptedException e) {
            System.out.println(taskName + <span class="string">" was interrupted"</span>);
            Thread.currentThread().interrupt();
        }
        System.out.println(taskName + <span class="string">" finished"</span>);
    }
}

<span class="comment">// Usage</span>
<span class="type">TaskRunner</span> task = <span class="keyword">new</span> <span class="type">TaskRunner</span>(<span class="string">"EmailSender"</span>, <span class="number">800</span>);
<span class="type">Thread</span> thread = <span class="keyword">new</span> <span class="type">Thread</span>(task, <span class="string">"Email-Thread"</span>);
thread.start();</code></pre>
                            </div>

                            <div class="code-block">
                                <div class="code-header">
                                    <span><i class="fab fa-java"></i> Method 3: Using ExecutorService (Production Recommended)</span>
                                </div>
                                <pre><code><span class="keyword">import</span> java.util.concurrent.*;
<span class="keyword">import</span> java.util.List;
<span class="keyword">import</span> java.util.ArrayList;

<span class="keyword">public class</span> <span class="type">ExecutorServiceExample</span> {
    <span class="keyword">public static void</span> main(<span class="type">String</span>[] args) {
        <span class="comment">// Create different types of thread pools</span>
        <span class="type">ExecutorService</span> fixedPool = Executors.newFixedThreadPool(<span class="number">3</span>);
        <span class="type">ExecutorService</span> cachedPool = Executors.newCachedThreadPool();
        <span class="type">ScheduledExecutorService</span> scheduledPool = Executors.newScheduledThreadPool(<span class="number">2</span>);

        <span class="keyword">try</span> {
            <span class="comment">// Submit Runnable tasks</span>
            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <= <span class="number">5</span>; i++) {
                <span class="keyword">final int</span> taskId = i;
                fixedPool.submit(() -> {
                    System.out.println(<span class="string">"Task "</span> + taskId + <span class="string">" running in: "</span> +
                                     Thread.currentThread().getName());
                    <span class="keyword">try</span> { Thread.sleep(<span class="number">2000</span>); }
                    <span class="keyword">catch</span> (InterruptedException e) { Thread.currentThread().interrupt(); }
                    System.out.println(<span class="string">"Task "</span> + taskId + <span class="string">" completed"</span>);
                });
            }

            <span class="comment">// Submit Callable tasks with return values</span>
            <span class="type">List</span>&lt;<span class="type">Future</span>&lt;<span class="type">String</span>&gt;&gt; futures = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();
            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <= <span class="number">4</span>; i++) {
                <span class="keyword">final int</span> taskId = i;
                <span class="type">Future</span>&lt;<span class="type">String</span>&gt; future = cachedPool.submit(() -> {
                    Thread.sleep(<span class="number">1000</span> + taskId * <span class="number">300</span>);
                    <span class="keyword">return</span> <span class="string">"Result from task "</span> + taskId;
                });
                futures.add(future);
            }

            <span class="comment">// Collect results with timeout</span>
            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < futures.size(); i++) {
                <span class="keyword">try</span> {
                    <span class="type">String</span> result = futures.get(i).get(<span class="number">3</span>, TimeUnit.SECONDS);
                    System.out.println(result);
                } <span class="keyword">catch</span> (TimeoutException e) {
                    System.out.println(<span class="string">"Task timed out"</span>);
                    futures.get(i).cancel(<span class="keyword">true</span>);
                } <span class="keyword">catch</span> (ExecutionException e) {
                    System.out.println(<span class="string">"Task failed: "</span> + e.getCause());
                }
            }

            <span class="comment">// Scheduled tasks</span>
            scheduledPool.scheduleWithFixedDelay(() -> {
                System.out.println(<span class="string">"Periodic task at: "</span> + System.currentTimeMillis());
            }, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);

            Thread.sleep(<span class="number">5000</span>);

        } <span class="keyword">catch</span> (InterruptedException e) {
            Thread.currentThread().interrupt();
        } <span class="keyword">finally</span> {
            <span class="comment">// Proper shutdown</span>
            fixedPool.shutdown();
            cachedPool.shutdown();
            scheduledPool.shutdown();
        }
    }
}</code></pre>
                            </div>

                            <div class="table-container">
                                <table>
                                    <thead>
                                        <tr>
                                            <th>Method</th>
                                            <th>Pros</th>
                                            <th>Cons</th>
                                            <th>Best Use Case</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>Extend Thread</td>
                                            <td>Simple, direct control</td>
                                            <td>No multiple inheritance</td>
                                            <td>Simple standalone threads</td>
                                        </tr>
                                        <tr>
                                            <td>Implement Runnable</td>
                                            <td>Better OOP design, flexible</td>
                                            <td>More verbose</td>
                                            <td>When inheritance flexibility needed</td>
                                        </tr>
                                        <tr>
                                            <td>ExecutorService</td>
                                            <td>Thread pool management</td>
                                            <td>More complex API</td>
                                            <td>Production applications</td>
                                        </tr>
                                        <tr>
                                            <td>CompletableFuture</td>
                                            <td>Modern, composable</td>
                                            <td>Learning curve</td>
                                            <td>Async pipelines</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </section>

                    <!-- Section 4: Thread Lifecycle -->
                    <section id="lifecycle" class="chapter">
                        <h2 class="chapter-title">4. Thread Lifecycle and States</h2>
                        <div class="chapter-content">
                            <div class="info-box">
                                <h4><i class="fas fa-sync-alt"></i> Understanding Thread States</h4>
                                <p>Threads in Java go through various states during their lifecycle. Understanding these states is crucial for debugging, monitoring, and optimizing concurrent applications.</p>
                            </div>

                            <div class="feature-grid">
                                <div class="card">
                                    <h4>NEW</h4>
                                    <p>Thread created but not started</p>
                                    <small>Created with new Thread() but start() not called</small>
                                </div>
                                <div class="card">
                                    <h4>RUNNABLE</h4>
                                    <p>Thread executing or ready to execute</p>
                                    <small>Either running or waiting for CPU time</small>
                                </div>
                                <div class="card">
                                    <h4>BLOCKED</h4>
                                    <p>Thread blocked waiting for monitor lock</p>
                                    <small>Waiting to enter synchronized block</small>
                                </div>
                                <div class="card">
                                    <h4>WAITING</h4>
                                    <p>Thread waiting indefinitely</p>
                                    <small>Called wait(), join(), or LockSupport.park()</small>
                                </div>
                                <div class="card">
                                    <h4>TIMED_WAITING</h4>
                                    <p>Thread waiting for specified time</p>
                                    <small>Called sleep(), wait(timeout), or join(timeout)</small>
                                </div>
                                <div class="card">
                                    <h4>TERMINATED</h4>
                                    <p>Thread completed execution</p>
                                    <small>run() method finished or exception occurred</small>
                                </div>
                            </div>

                            <div class="code-block">
                                <div class="code-header">
                                    <span><i class="fab fa-java"></i> Thread Lifecycle Demonstration</span>
                                </div>
                                <pre><code><span class="keyword">public class</span> <span class="type">ThreadLifecycleDemo</span> {
    <span class="keyword">public static void</span> main(<span class="type">String</span>[] args) <span class="keyword">throws</span> InterruptedException {
        <span class="type">Object</span> sharedLock = <span class="keyword">new</span> <span class="type">Object</span>();

        <span class="type">Thread</span> workerThread = <span class="keyword">new</span> <span class="type">Thread</span>(() -> {
            <span class="keyword">try</span> {
                System.out.println(<span class="string">"Worker: Starting execution"</span>);

                <span class="comment">// Demonstrate TIMED_WAITING state</span>
                System.out.println(<span class="string">"Worker: Going to sleep"</span>);
                Thread.sleep(<span class="number">2000</span>);
                System.out.println(<span class="string">"Worker: Woke up"</span>);

                <span class="comment">// Demonstrate WAITING state</span>
                <span class="keyword">synchronized</span> (sharedLock) {
                    System.out.println(<span class="string">"Worker: Waiting for notification"</span>);
                    sharedLock.wait();
                    System.out.println(<span class="string">"Worker: Received notification"</span>);
                }

                System.out.println(<span class="string">"Worker: Completing execution"</span>);

            } <span class="keyword">catch</span> (InterruptedException e) {
                System.out.println(<span class="string">"Worker: Was interrupted"</span>);
                Thread.currentThread().interrupt();
            }
        }, <span class="string">"WorkerThread"</span>);

        <span class="comment">// NEW state</span>
        System.out.println(<span class="string">"Initial state: "</span> + workerThread.getState());

        workerThread.start();

        <span class="comment">// Let worker enter sleep state</span>
        Thread.sleep(<span class="number">1000</span>);
        System.out.println(<span class="string">"During sleep: "</span> + workerThread.getState());

        <span class="comment">// Let worker enter wait state</span>
        Thread.sleep(<span class="number">2000</span>);
        System.out.println(<span class="string">"During wait: "</span> + workerThread.getState());

        <span class="comment">// Notify worker</span>
        Thread.sleep(<span class="number">1000</span>);
        <span class="keyword">synchronized</span> (sharedLock) {
            System.out.println(<span class="string">"Main: Notifying worker"</span>);
            sharedLock.notify();
        }

        workerThread.join();
        System.out.println(<span class="string">"Final state: "</span> + workerThread.getState());
    }
}</code></pre>
                            </div>

                            <div class="highlight-box">
                                <h4><i class="fas fa-lightbulb"></i> Best Practice</h4>
                                <p>Always use cooperative interruption rather than deprecated methods like stop(). Check Thread.currentThread().isInterrupted() regularly in long-running loops and handle InterruptedException properly.</p>
                            </div>
                        </div>
                    </section>

                    <!-- Section 5: Synchronization -->
                    <section id="synchronization" class="chapter">
                        <h2 class="chapter-title">5. Synchronization Mechanisms</h2>
                        <div class="chapter-content">
                            <div class="info-box">
                                <h4><i class="fas fa-lock"></i> Thread Synchronization</h4>
                                <p>Synchronization prevents race conditions and ensures thread safety when multiple threads access shared resources. Java provides multiple synchronization mechanisms for different scenarios.</p>
                            </div>

                            <div class="code-block">
                                <div class="code-header">
                                    <span><i class="fab fa-java"></i> The Race Condition Problem</span>
                                </div>
                                <pre><code><span class="keyword">class</span> <span class="type">UnsafeCounter</span> {
    <span class="keyword">private int</span> count = <span class="number">0</span>;

    <span class="keyword">public void</span> increment() {
        <span class="comment">// This operation is NOT atomic!</span>
        <span class="comment">// 1. Read current value of count</span>
        <span class="comment">// 2. Add 1 to the value</span>
        <span class="comment">// 3. Write the result back to count</span>
        count++;
    }

    <span class="keyword">public int</span> getCount() {
        <span class="keyword">return</span> count;
    }
}

<span class="keyword">public class</span> <span class="type">RaceConditionDemo</span> {
    <span class="keyword">public static void</span> main(<span class="type">String</span>[] args) <span class="keyword">throws</span> InterruptedException {
        <span class="type">UnsafeCounter</span> counter = <span class="keyword">new</span> <span class="type">UnsafeCounter</span>();
        <span class="keyword">int</span> numThreads = <span class="number">10</span>;
        <span class="keyword">int</span> incrementsPerThread = <span class="number">1000</span>;

        <span class="type">Thread</span>[] threads = <span class="keyword">new</span> <span class="type">Thread</span>[numThreads];

        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < numThreads; i++) {
            threads[i] = <span class="keyword">new</span> <span class="type">Thread</span>(() -> {
                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < incrementsPerThread; j++) {
                    counter.increment();
                }
            });
        }

        <span class="keyword">for</span> (<span class="type">Thread</span> thread : threads) thread.start();
        <span class="keyword">for</span> (<span class="type">Thread</span> thread : threads) thread.join();

        <span class="keyword">int</span> expected = numThreads * incrementsPerThread;
        System.out.println(<span class="string">"Expected: "</span> + expected);
        System.out.println(<span class="string">"Actual: "</span> + counter.getCount());
        System.out.println(<span class="string">"Lost updates: "</span> + (expected - counter.getCount()));
    }
}</code></pre>
                            </div>

                            <div class="code-block">
                                <div class="code-header">
                                    <span><i class="fab fa-java"></i> Synchronized Solution</span>
                                </div>
                                <pre><code><span class="keyword">class</span> <span class="type">SafeCounter</span> {
    <span class="keyword">private int</span> count = <span class="number">0</span>;
    <span class="keyword">private final</span> <span class="type">Object</span> lock = <span class="keyword">new</span> <span class="type">Object</span>();

    <span class="comment">// Synchronized method - uses intrinsic lock</span>
    <span class="keyword">public synchronized void</span> increment() {
        count++;
    }

    <span class="comment">// Synchronized block with custom lock object</span>
    <span class="keyword">public void</span> decrement() {
        <span class="keyword">synchronized</span> (lock) {
            count--;
        }
    }

    <span class="keyword">public synchronized int</span> getCount() {
        <span class="keyword">return</span> count;
    }
}

<span class="comment">// Thread-safe bank account example</span>
<span class="keyword">class</span> <span class="type">BankAccount</span> {
    <span class="keyword">private double</span> balance;
    <span class="keyword">private final</span> <span class="type">Object</span> balanceLock = <span class="keyword">new</span> <span class="type">Object</span>();

    <span class="keyword">public</span> BankAccount(<span class="keyword">double</span> initialBalance) {
        <span class="keyword">this</span>.balance = initialBalance;
    }

    <span class="keyword">public void</span> deposit(<span class="keyword">double</span> amount) {
        <span class="keyword">if</span> (amount <= <span class="number">0</span>) <span class="keyword">throw new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"Amount must be positive"</span>);

        <span class="keyword">synchronized</span> (balanceLock) {
            <span class="keyword">double</span> oldBalance = balance;
            balance += amount;
            System.out.println(Thread.currentThread().getName() +
                             <span class="string">" deposited $"</span> + amount +
                             <span class="string">" (Balance: $"</span> + oldBalance + <span class="string">" -> $"</span> + balance + <span class="string">")"</span>);
        }
    }

    <span class="keyword">public boolean</span> withdraw(<span class="keyword">double</span> amount) {
        <span class="keyword">synchronized</span> (balanceLock) {
            <span class="keyword">if</span> (balance >= amount) {
                balance -= amount;
                System.out.println(Thread.currentThread().getName() +
                                 <span class="string">" withdrew $"</span> + amount);
                <span class="keyword">return true</span>;
            }
            <span class="keyword">return false</span>;
        }
    }

    <span class="keyword">public synchronized double</span> getBalance() {
        <span class="keyword">return</span> balance;
    }
}</code></pre>
                            </div>

                            <div class="info-box" style="background: linear-gradient(135deg, #ff6b6b22, #feca5722); border-left-color: #ff6b6b;">
                                <h4><i class="fas fa-exclamation-triangle"></i> Deadlock Warning</h4>
                                <p>Always acquire multiple locks in a consistent order across all threads to prevent deadlocks. Consider using lock timeouts and proper exception handling in critical sections.</p>
                            </div>
                        </div>
                    </section>

                    <!-- Section 6: Concurrent Collections -->
                    <section id="collections" class="chapter">
                        <h2 class="chapter-title">6. Concurrent Collections</h2>
                        <div class="chapter-content">
                            <div class="info-box">
                                <h4><i class="fas fa-database"></i> Thread-Safe Collections</h4>
                                <p>Java provides specialized concurrent collections designed for high-performance thread-safe operations without requiring external synchronization.</p>
                            </div>

                            <div class="code-block">
                                <div class="code-header">
                                    <span><i class="fab fa-java"></i> ConcurrentHashMap Example</span>
                                </div>
                                <pre><code><span class="keyword">import</span> java.util.concurrent.*;

<span class="keyword">public class</span> <span class="type">ConcurrentHashMapDemo</span> {
    <span class="keyword">public static void</span> main(<span class="type">String</span>[] args) <span class="keyword">throws</span> InterruptedException {
        <span class="type">ConcurrentHashMap</span>&lt;<span class="type">String</span>, <span class="type">Integer</span>&gt; concurrentMap = <span class="keyword">new</span> <span class="type">ConcurrentHashMap</span>&lt;&gt;();
        concurrentMap.put(<span class="string">"globalCounter"</span>, <span class="number">0</span>);

        <span class="type">Thread</span>[] threads = <span class="keyword">new</span> <span class="type">Thread</span>[<span class="number">5</span>];

        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">5</span>; i++) {
            <span class="keyword">final int</span> threadId = i;
            threads[i] = <span class="keyword">new</span> <span class="type">Thread</span>(() -> {
                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < <span class="number">1000</span>; j++) {
                    <span class="comment">// Atomic increment using compute</span>
                    concurrentMap.compute(<span class="string">"globalCounter"</span>, (key, val) ->
                        val == <span class="keyword">null</span> ? <span class="number">1</span> : val + <span class="number">1</span>);

                    <span class="comment">// Atomic addition using merge</span>
                    concurrentMap.merge(<span class="string">"thread-"</span> + threadId, <span class="number">1</span>, Integer::sum);
                }
            });
        }

        <span class="keyword">for</span> (<span class="type">Thread</span> thread : threads) thread.start();
        <span class="keyword">for</span> (<span class="type">Thread</span> thread : threads) thread.join();

        System.out.println(<span class="string">"Global counter: "</span> + concurrentMap.get(<span class="string">"globalCounter"</span>));
        System.out.println(<span class="string">"Expected: 5000"</span>);

        <span class="comment">// Safe iteration</span>
        concurrentMap.forEach((key, value) -> System.out.println(key + <span class="string">" = "</span> + value));
    }
}</code></pre>
                            </div>

                            <div class="code-block">
                                <div class="code-header">
                                    <span><i class="fab fa-java"></i> BlockingQueue - Producer-Consumer Pattern</span>
                                </div>
                                <pre><code><span class="keyword">import</span> java.util.concurrent.*;

<span class="keyword">public class</span> <span class="type">BlockingQueueDemo</span> {
    <span class="keyword">private static final</span> <span class="type">String</span> POISON_PILL = <span class="string">"STOP"</span>;

    <span class="keyword">public static void</span> main(<span class="type">String</span>[] args) <span class="keyword">throws</span> InterruptedException {
        <span class="type">BlockingQueue</span>&lt;<span class="type">String</span>&gt; queue = <span class="keyword">new</span> <span class="type">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>);

        <span class="comment">// Producer</span>
        <span class="type">Thread</span> producer = <span class="keyword">new</span> <span class="type">Thread</span>(() -> {
            <span class="keyword">try</span> {
                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <= <span class="number">20</span>; i++) {
                    <span class="type">String</span> item = <span class="string">"Task-"</span> + i;
                    System.out.println(<span class="string">"[Producer] Creating: "</span> + item);
                    queue.put(item); <span class="comment">// Blocks if queue is full</span>
                    Thread.sleep(<span class="number">150</span>);
                }
                queue.put(POISON_PILL);
                queue.put(POISON_PILL);
            } <span class="keyword">catch</span> (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, <span class="string">"Producer"</span>);

        <span class="comment">// Consumers</span>
        <span class="type">Thread</span> consumer1 = <span class="keyword">new</span> <span class="type">Thread</span>(() -> consume(queue), <span class="string">"Consumer-1"</span>);
        <span class="type">Thread</span> consumer2 = <span class="keyword">new</span> <span class="type">Thread</span>(() -> consume(queue), <span class="string">"Consumer-2"</span>);

        producer.start();
        consumer1.start();
        consumer2.start();

        producer.join();
        consumer1.join();
        consumer2.join();

        System.out.println(<span class="string">"Demo completed"</span>);
    }

    <span class="keyword">private static void</span> consume(<span class="type">BlockingQueue</span>&lt;<span class="type">String</span>&gt; queue) {
        <span class="keyword">try</span> {
            <span class="keyword">while</span> (<span class="keyword">true</span>) {
                <span class="type">String</span> item = queue.take(); <span class="comment">// Blocks if queue is empty</span>
                <span class="keyword">if</span> (item.equals(POISON_PILL)) {
                    System.out.println(<span class="string">"["</span> + Thread.currentThread().getName() + <span class="string">"] Stopping"</span>);
                    <span class="keyword">break</span>;
                }
                System.out.println(<span class="string">"["</span> + Thread.currentThread().getName() + <span class="string">"] Processing: "</span> + item);
                Thread.sleep(<span class="number">500</span>);
            }
        } <span class="keyword">catch</span> (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}</code></pre>
                            </div>

                            <div class="table-container">
                                <table>
                                    <thead>
                                        <tr>
                                            <th>Collection</th>
                                            <th>Use Case</th>
                                            <th>Read Performance</th>
                                            <th>Write Performance</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>ConcurrentHashMap</td>
                                            <td>High concurrency read/write</td>
                                            <td>Excellent</td>
                                            <td>Excellent</td>
                                        </tr>
                                        <tr>
                                            <td>CopyOnWriteArrayList</td>
                                            <td>Read-heavy, rare writes</td>
                                            <td>Excellent</td>
                                            <td>Poor</td>
                                        </tr>
                                        <tr>
                                            <td>ArrayBlockingQueue</td>
                                            <td>Bounded producer-consumer</td>
                                            <td>Good</td>
                                            <td>Good</td>
                                        </tr>
                                        <tr>
                                            <td>LinkedBlockingQueue</td>
                                            <td>Unbounded producer-consumer</td>
                                            <td>Good</td>
                                            <td>Good</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </section>

                    <!-- Section 7: Advanced Concurrency -->
                    <section id="advanced" class="chapter">
                        <h2 class="chapter-title">7. Advanced Concurrency Utilities</h2>
                        <div class="chapter-content">
                            <div class="info-box">
                                <h4><i class="fas fa-cogs"></i> High-Level Synchronization Tools</h4>
                                <p>Java provides sophisticated synchronization utilities beyond basic locks for complex coordination scenarios like barriers, latches, and semaphores.</p>
                            </div>

                            <div class="code-block">
                                <div class="code-header">
                                    <span><i class="fab fa-java"></i> CountDownLatch - Service Startup Coordination</span>
                                </div>
                                <pre><code><span class="keyword">import</span> java.util.concurrent.*;

<span class="keyword">public class</span> <span class="type">CountDownLatchDemo</span> {
    <span class="keyword">public static void</span> main(<span class="type">String</span>[] args) <span class="keyword">throws</span> InterruptedException {
        <span class="keyword">int</span> numberOfServices = <span class="number">4</span>;
        <span class="type">CountDownLatch</span> allServicesReady = <span class="keyword">new</span> <span class="type">CountDownLatch</span>(numberOfServices);

        <span class="type">String</span>[] services = {<span class="string">"Database"</span>, <span class="string">"Cache"</span>, <span class="string">"Web"</span>, <span class="string">"Security"</span>};
        <span class="keyword">int</span>[] startupTimes = {<span class="number">2000</span>, <span class="number">1500</span>, <span class="number">1000</span>, <span class="number">2500</span>};

        System.out.println(<span class="string">"=== Application Startup ==="</span>);
        <span class="keyword">long</span> start = System.currentTimeMillis();

        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < numberOfServices; i++) {
            <span class="keyword">final int</span> index = i;
            <span class="keyword">new</span> <span class="type">Thread</span>(() -> {
                <span class="keyword">try</span> {
                    System.out.println(services[index] + <span class="string">" starting..."</span>);
                    Thread.sleep(startupTimes[index]);
                    System.out.println(services[index] + <span class="string">" started"</span>);
                    allServicesReady.countDown();
                } <span class="keyword">catch</span> (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
        }

        System.out.println(<span class="string">"Waiting for all services..."</span>);
        allServicesReady.await();

        <span class="keyword">long</span> end = System.currentTimeMillis();
        System.out.println(<span class="string">"All services started! Total time: "</span> + (end - start) + <span class="string">"ms"</span>);
    }
}</code></pre>
                            </div>

                            <div class="code-block">
                                <div class="code-header">
                                    <span><i class="fab fa-java"></i> Semaphore - Resource Pool Management</span>
                                </div>
                                <pre><code><span class="keyword">import</span> java.util.concurrent.*;

<span class="keyword">class</span> <span class="type">ConnectionPool</span> {
    <span class="keyword">private final</span> <span class="type">Semaphore</span> availableConnections;
    <span class="keyword">private final int</span> maxConnections;

    <span class="keyword">public</span> ConnectionPool(<span class="keyword">int</span> maxConnections) {
        <span class="keyword">this</span>.maxConnections = maxConnections;
        <span class="keyword">this</span>.availableConnections = <span class="keyword">new</span> <span class="type">Semaphore</span>(maxConnections, <span class="keyword">true</span>);
    }

    <span class="keyword">public void</span> getConnection() <span class="keyword">throws</span> InterruptedException {
        availableConnections.acquire();
        System.out.println(<span class="string">"["</span> + Thread.currentThread().getName() +
                         <span class="string">"] Acquired connection (available: "</span> +
                         availableConnections.availablePermits() + <span class="string">")"</span>);
    }

    <span class="keyword">public void</span> releaseConnection() {
        System.out.println(<span class="string">"["</span> + Thread.currentThread().getName() +
                         <span class="string">"] Released connection"</span>);
        availableConnections.release();
    }
}

<span class="keyword">public class</span> <span class="type">SemaphoreDemo</span> {
    <span class="keyword">public static void</span> main(<span class="type">String</span>[] args) <span class="keyword">throws</span> InterruptedException {
        <span class="type">ConnectionPool</span> pool = <span class="keyword">new</span> <span class="type">ConnectionPool</span>(<span class="number">3</span>);
        <span class="keyword">int</span> numberOfClients = <span class="number">8</span>;

        <span class="type">Thread</span>[] clients = <span class="keyword">new</span> <span class="type">Thread</span>[numberOfClients];

        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < numberOfClients; i++) {
            clients[i] = <span class="keyword">new</span> <span class="type">Thread</span>(() -> {
                <span class="keyword">try</span> {
                    pool.getConnection();
                    Thread.sleep(<span class="number">1000</span> + (<span class="keyword">int</span>)(Math.random() * <span class="number">2000</span>));
                } <span class="keyword">catch</span> (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } <span class="keyword">finally</span> {
                    pool.releaseConnection();
                }
            }, <span class="string">"Client-"</span> + i);
        }

        <span class="keyword">for</span> (<span class="type">Thread</span> client : clients) client.start();
        <span class="keyword">for</span> (<span class="type">Thread</span> client : clients) client.join();

        System.out.println(<span class="string">"All clients completed"</span>);
    }
}</code></pre>
                            </div>

                            <div class="highlight-box">
                                <h4><i class="fas fa-lightbulb"></i> Performance Tip</h4>
                                <p>Use fair semaphores (true parameter) when you need to prevent thread starvation, but note that fair semaphores have slightly lower performance than unfair ones.</p>
                            </div>
                        </div>
                    </section>

                    <!-- Section 8: Best Practices -->
                    <section id="best-practices" class="chapter">
                        <h2 class="chapter-title">8. Best Practices and Performance</h2>
                        <div class="chapter-content">
                            <div class="info-box">
                                <h4><i class="fas fa-star"></i> Production-Ready Threading</h4>
                                <p>Writing robust, maintainable, and high-performance concurrent code requires following established patterns and avoiding common pitfalls.</p>
                            </div>

                            <div class="feature-grid">
                                <div class="card">
                                    <h4>Thread Safety Principles</h4>
                                    <ul>
                                        <li>Prefer immutable objects when possible</li>
                                        <li>Minimize shared mutable state</li>
                                        <li>Use thread-safe collections</li>
                                        <li>Avoid shared variables between threads</li>
                                        <li>Use defensive copying for mutable objects</li>
                                    </ul>
                                </div>
                                <div class="card">
                                    <h4>Performance Guidelines</h4>
                                    <ul>
                                        <li>Use thread pools instead of creating threads</li>
                                        <li>Choose appropriate pool sizes</li>
                                        <li>Avoid excessive synchronization</li>
                                        <li>Use lock-free algorithms when possible</li>
                                        <li>Profile and measure performance</li>
                                    </ul>
                                </div>
                                <div class="card">
                                    <h4>Error Handling</h4>
                                    <ul>
                                        <li>Always handle InterruptedException properly</li>
                                        <li>Use UncaughtExceptionHandler for critical threads</li>
                                        <li>Implement proper shutdown sequences</li>
                                        <li>Use timeouts to avoid infinite waits</li>
                                        <li>Log thread-related errors with context</li>
                                    </ul>
                                </div>
                            </div>

                            <div class="code-block">
                                <div class="code-header">
                                    <span><i class="fab fa-java"></i> Production Thread Pool Configuration</span>
                                </div>
                                <pre><code><span class="keyword">import</span> java.util.concurrent.*;
<span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;

<span class="keyword">public class</span> <span class="type">ProductionThreadPoolExample</span> {

    <span class="comment">// Custom thread factory for better debugging</span>
    <span class="keyword">private static class</span> <span class="type">NamedThreadFactory</span> <span class="keyword">implements</span> <span class="type">ThreadFactory</span> {
        <span class="keyword">private final</span> <span class="type">String</span> namePrefix;
        <span class="keyword">private final</span> <span class="type">AtomicInteger</span> threadNumber = <span class="keyword">new</span> <span class="type">AtomicInteger</span>(<span class="number">1</span>);

        <span class="keyword">public</span> NamedThreadFactory(<span class="type">String</span> namePrefix) {
            <span class="keyword">this</span>.namePrefix = namePrefix;
        }

        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="type">Thread</span> newThread(<span class="type">Runnable</span> r) {
            <span class="type">Thread</span> thread = <span class="keyword">new</span> <span class="type">Thread</span>(r, namePrefix + <span class="string">"-"</span> + threadNumber.getAndIncrement());
            thread.setUncaughtExceptionHandler((t, e) -> {
                System.err.println(<span class="string">"Thread "</span> + t.getName() + <span class="string">" threw: "</span> + e.getMessage());
            });
            <span class="keyword">return</span> thread;
        }
    }

    <span class="keyword">public static void</span> main(<span class="type">String</span>[] args) <span class="keyword">throws</span> InterruptedException {
        <span class="comment">// CPU-bound task pool</span>
        <span class="keyword">int</span> cpuCores = Runtime.getRuntime().availableProcessors();
        <span class="type">ThreadPoolExecutor</span> cpuBoundPool = <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(
            cpuCores,
            cpuCores,
            <span class="number">60</span>L, TimeUnit.SECONDS,
            <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100</span>),
            <span class="keyword">new</span> <span class="type">NamedThreadFactory</span>(<span class="string">"CPU-Worker"</span>)
        );

        <span class="comment">// I/O-bound task pool</span>
        <span class="type">ThreadPoolExecutor</span> ioBoundPool = <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(
            <span class="number">10</span>,
            <span class="number">50</span>,
            <span class="number">60</span>L, TimeUnit.SECONDS,
            <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">200</span>),
            <span class="keyword">new</span> <span class="type">NamedThreadFactory</span>(<span class="string">"IO-Worker"</span>),
            <span class="keyword">new</span> <span class="type">ThreadPoolExecutor.CallerRunsPolicy</span>()
        );

        <span class="keyword">try</span> {
            <span class="comment">// Submit tasks...</span>
            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">10</span>; i++) {
                <span class="keyword">final int</span> taskId = i;
                cpuBoundPool.submit(() -> {
                    System.out.println(<span class="string">"CPU Task "</span> + taskId + <span class="string">" running"</span>);
                });
            }

            Thread.sleep(<span class="number">5000</span>);

        } <span class="keyword">finally</span> {
            shutdownGracefully(cpuBoundPool, <span class="string">"CPU Pool"</span>);
            shutdownGracefully(ioBoundPool, <span class="string">"I/O Pool"</span>);
        }
    }

    <span class="keyword">private static void</span> shutdownGracefully(<span class="type">ExecutorService</span> executor, <span class="type">String</span> name) {
        executor.shutdown();
        <span class="keyword">try</span> {
            <span class="keyword">if</span> (!executor.awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
        } <span class="keyword">catch</span> (InterruptedException e) {
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
}</code></pre>
                            </div>

                            <div class="info-box" style="background: linear-gradient(135deg, #ff6b6b22, #feca5722); border-left-color: #ff6b6b;">
                                <h4><i class="fas fa-exclamation-triangle"></i> Common Pitfalls</h4>
                                <p>Resource leaks from not shutting down thread pools, deadlocks from inconsistent lock ordering, performance issues from excessive context switching, and race conditions from inadequate synchronization.</p>
                            </div>
                        </div>
                    </section>

                    <!-- Section 9: Interview Questions -->
                    <section id="interview" class="chapter">
                        <h2 class="chapter-title">9. Interview Questions</h2>
                        <div class="chapter-content">
                            <div class="info-box">
                                <h4><i class="fas fa-question-circle"></i> Common Interview Topics</h4>
                                <p>Master these commonly asked multithreading interview questions to demonstrate your understanding of concurrent programming concepts.</p>
                            </div>

                            <div class="feature-grid">
                                <div class="card">
                                    <h4>Conceptual Questions</h4>
                                    <ul>
                                        <li><strong>Q:</strong> What is the difference between process and thread?</li>
                                        <li><strong>Q:</strong> Explain synchronized vs volatile keywords.</li>
                                        <li><strong>Q:</strong> What is a race condition and how to prevent it?</li>
                                        <li><strong>Q:</strong> When to use CountDownLatch vs CyclicBarrier?</li>
                                    </ul>
                                </div>
                                <div class="card">
                                    <h4>Coding Questions</h4>
                                    <ul>
                                        <li><strong>Q:</strong> Implement a thread-safe singleton.</li>
                                        <li><strong>Q:</strong> Create a producer-consumer solution.</li>
                                        <li><strong>Q:</strong> Print numbers 1-100 using 3 threads alternately.</li>
                                        <li><strong>Q:</strong> Implement a thread-safe counter.</li>
                                    </ul>
                                </div>
                                <div class="card">
                                    <h4>Advanced Questions</h4>
                                    <ul>
                                        <li><strong>Q:</strong> How does ConcurrentHashMap achieve thread safety?</li>
                                        <li><strong>Q:</strong> Explain happens-before relationship.</li>
                                        <li><strong>Q:</strong> How to detect and prevent deadlocks?</li>
                                        <li><strong>Q:</strong> What are lock-free algorithms?</li>
                                    </ul>
                                </div>
                            </div>

                            <div class="code-block">
                                <div class="code-header">
                                    <span><i class="fab fa-java"></i> Sample Interview Coding Problem</span>
                                </div>
                                <pre><code><span class="comment">// Problem: Implement a thread-safe counter with increment,</span>
<span class="comment">// decrement, and get operations.</span>

<span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;

<span class="comment">// Solution 1: Using AtomicInteger (preferred)</span>
<span class="keyword">class</span> <span class="type">AtomicCounter</span> {
    <span class="keyword">private final</span> <span class="type">AtomicInteger</span> count = <span class="keyword">new</span> <span class="type">AtomicInteger</span>(<span class="number">0</span>);

    <span class="keyword">public void</span> increment() {
        count.incrementAndGet();
    }

    <span class="keyword">public void</span> decrement() {
        count.decrementAndGet();
    }

    <span class="keyword">public int</span> get() {
        <span class="keyword">return</span> count.get();
    }
}

<span class="comment">// Test</span>
<span class="keyword">public class</span> <span class="type">CounterTest</span> {
    <span class="keyword">public static void</span> main(<span class="type">String</span>[] args) <span class="keyword">throws</span> InterruptedException {
        <span class="type">AtomicCounter</span> counter = <span class="keyword">new</span> <span class="type">AtomicCounter</span>();
        <span class="keyword">int</span> numThreads = <span class="number">10</span>;
        <span class="keyword">int</span> ops = <span class="number">1000</span>;

        <span class="type">Thread</span>[] threads = <span class="keyword">new</span> <span class="type">Thread</span>[numThreads];

        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < numThreads; i++) {
            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) {
                threads[i] = <span class="keyword">new</span> <span class="type">Thread</span>(() -> {
                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < ops; j++) counter.increment();
                });
            } <span class="keyword">else</span> {
                threads[i] = <span class="keyword">new</span> <span class="type">Thread</span>(() -> {
                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < ops; j++) counter.decrement();
                });
            }
        }

        <span class="keyword">for</span> (<span class="type">Thread</span> t : threads) t.start();
        <span class="keyword">for</span> (<span class="type">Thread</span> t : threads) t.join();

        System.out.println(<span class="string">"Final value: "</span> + counter.get());
        System.out.println(<span class="string">"Expected: 0"</span>);
    }
}</code></pre>
                            </div>

                            <div class="highlight-box">
                                <h4><i class="fas fa-graduation-cap"></i> Interview Success Tips</h4>
                                <ul>
                                    <li><strong>Understand Fundamentals:</strong> Know thread lifecycle, states, and basic synchronization primitives</li>
                                    <li><strong>Practice Coding:</strong> Implement common patterns like producer-consumer and thread pools</li>
                                    <li><strong>Know Collections:</strong> Understand when to use ConcurrentHashMap vs CopyOnWriteArrayList</li>
                                    <li><strong>Explain Trade-offs:</strong> Discuss performance vs complexity and safety vs speed</li>
                                    <li><strong>Real-world Examples:</strong> Be ready to discuss practical applications</li>
                                </ul>
                            </div>
                        </div>
                    </section>
                </div>

                <footer class="article-nav">
                    <a href="/java/advanced/java_collections_book.html" class="nav-link prev">
                        <span>Previous</span>
                        <strong>Java Collections Framework</strong>
                    </a>
                    <a href="/java/misc/java-generics.html" class="nav-link next">
                        <span>Next</span>
                        <strong>Java Generics</strong>
                    </a>
                </footer>
            </article>
        </div>
    </main>

    <footer class="site-footer" id="site-footer"></footer>
    <button class="back-to-top" id="back-to-top" type="button" aria-label="Back to top">
        <i class="fas fa-chevron-up"></i>
    </button>

    <script src="/js/navigation-data.js"></script>
    <script src="/js/components.js"></script>
</body>
</html>
